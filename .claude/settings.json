{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q 'features/.*\\.zig$'; then CONTENT=$(jq -r '(.tool_input.new_string // \"\") + (.tool_input.content // \"\")'); if echo \"$CONTENT\" | grep -q '@import(\"abi\")'; then echo 'ðŸš« BLOCKED: @import(\"abi\") in features/ causes circular imports. Use relative imports to services/shared/ instead.' >&2; exit 1; fi; fi"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q '\\.zig$'; then ~/.zvm/master/zig fmt \"$FILE\" 2>/dev/null || true; fi"
          }
        ]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q '/mod\\.zig$'; then STUB=$(echo \"$FILE\" | sed 's/mod\\.zig$/stub.zig/'); [ -f \"$STUB\" ] && echo \"âš  stub.zig exists alongside this mod.zig â€” remember to update $STUB to keep signatures in sync\" || true; fi"
          }
        ]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q '/build/options\\.zig$'; then echo 'âš  build/options.zig changed â€” also update build/flags.zig (FlagCombo, validation_matrix, comboToBuildOptions)'; fi"
          }
        ]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q 'feature_catalog\\.zig$'; then echo 'âš  feature_catalog.zig changed â€” also update: registry/types.zig (isFeatureCompiledIn), config/mod.zig (Feature enum, Config field), stub_parity.zig'; fi"
          }
        ]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q '/stub\\.zig$'; then MOD=$(echo \"$FILE\" | sed 's/stub\\.zig$/mod.zig/'); [ -f \"$MOD\" ] && echo \"âš  mod.zig exists alongside this stub.zig â€” verify $MOD doesn't need matching changes\" || true; fi"
          }
        ]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q '/build/flags\\.zig$'; then echo 'âš  build/flags.zig changed â€” also check build/options.zig (enable field + CLI option)'; fi"
          }
        ]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q '_test\\.zig$' && [ -f \"$FILE\" ] && grep -q 'comptime.*{.*_.*=.*@import' \"$FILE\" 2>/dev/null; then echo 'âš  Found comptime { _ = @import(...) } â€” use test { _ = @import(...); } for test discovery (comptime does NOT discover tests)'; fi"
          }
        ]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q '/src/abi\\.zig$'; then echo 'âš  src/abi.zig changed â€” update examples/ and verify public API surface. Run: zig build test --summary all'; fi"
          }
        ]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path // empty'); if [ -n \"$FILE\" ] && echo \"$FILE\" | grep -q '/tools/scripts/baseline\\.zig$'; then echo 'âš  Editing baseline.zig (source of truth for CI). Verify new numbers match actual test output. Run /baseline-sync after.'; fi"
          }
        ]
      },
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "COMMAND=$(jq -r '.tool_input.command // empty'); if echo \"$COMMAND\" | grep -qE 'zig build.*(feature-tests|test).*--summary'; then OUTPUT=$(jq -r '.tool_output // empty'); PASS=$(echo \"$OUTPUT\" | grep -oE '[0-9]+ pass' | head -1 | grep -oE '[0-9]+'); BASELINE_MAIN=$(grep test_main_pass tools/scripts/baseline.zig 2>/dev/null | grep -oE '[0-9]+'); BASELINE_FEAT=$(grep test_feature_pass tools/scripts/baseline.zig 2>/dev/null | grep -oE '[0-9]+'); if [ -n \"$PASS\" ] && [ -n \"$BASELINE_MAIN\" ] && [ \"$PASS\" != \"$BASELINE_MAIN\" ] && [ -n \"$BASELINE_FEAT\" ] && [ \"$PASS\" != \"$BASELINE_FEAT\" ]; then echo \"âš  Test count $PASS differs from baselines (main=$BASELINE_MAIN, feature=$BASELINE_FEAT). Run /baseline-sync if counts changed.\"; fi; fi"
          }
        ]
      }
    ]
  }
}
