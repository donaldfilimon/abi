
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Modern Zig framework for modular AI services, vector search, and systems tooling.">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>2026-01-17-comprehensive-roadmap-implementation - ABI Framework</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.484c7ddc.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#comprehensive-roadmap-implementation-plan" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="ABI Framework" class="md-header__button md-logo" aria-label="ABI Framework" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ABI Framework
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2026-01-17-comprehensive-roadmap-implementation
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/donaldfilimon/abi" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../docs/intro.md" class="md-tabs__link">
        
  
  
    
  
  Introduction

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../docs/framework.md" class="md-tabs__link">
        
  
  
    
  
  Framework

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../docs/compute.md" class="md-tabs__link">
        
  
  
    
  
  Compute

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../docs/gpu.md" class="md-tabs__link">
        
  
  
    
  
  GPU

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../docs/database.md" class="md-tabs__link">
        
  
  
    
  
  Database

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../docs/network.md" class="md-tabs__link">
        
  
  
    
  
  Network

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../docs/monitoring.md" class="md-tabs__link">
        
  
  
    
  
  Monitoring

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../docs/ai.md" class="md-tabs__link">
        
  
  
    
  
  AI

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../docs/migration/zig-0.16-migration.md" class="md-tabs__link">
          
  
  
  Migration

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="ABI Framework" class="md-nav__button md-logo" aria-label="ABI Framework" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    ABI Framework
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/donaldfilimon/abi" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/intro.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Introduction
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/framework.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Framework
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/compute.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Compute
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/gpu.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    GPU
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/database.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Database
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/network.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Network
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/monitoring.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Monitoring
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/ai.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    AI
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Migration
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            
  
    Migration
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/migration/zig-0.16-migration.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Zig 0.16 Migration
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#phase-1-gpu-modular-refactor-phase-3-completion" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 1: GPU Modular Refactor (Phase 3 Completion)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 1: GPU Modular Refactor (Phase 3 Completion)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-11-create-dispatcher-integration-for-unifiedzig" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 1.1: Create Dispatcher Integration for unified.zig
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-12-integrate-dispatcher-into-vectoradd" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 1.2: Integrate Dispatcher into vectorAdd
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-13-integrate-dispatcher-into-remaining-operations" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 1.3: Integrate Dispatcher into Remaining Operations
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-14-reduce-modzig-exports" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 1.4: Reduce mod.zig Exports
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-15-update-plan-document" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 1.5: Update Plan Document
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-2-documentation-infrastructure" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 2: Documentation Infrastructure
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 2: Documentation Infrastructure">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-21-create-api-documentation-generator-script" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 2.1: Create API Documentation Generator Script
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-22-create-architecture-diagram-sources" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 2.2: Create Architecture Diagram Sources
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-3-competitive-benchmark-framework" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 3: Competitive Benchmark Framework
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 3: Competitive Benchmark Framework">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-31-create-benchmark-runner-infrastructure" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 3.1: Create Benchmark Runner Infrastructure
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-32-implement-vector-operation-benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 3.2: Implement Vector Operation Benchmarks
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-4-high-availability-infrastructure" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 4: High Availability Infrastructure
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 4: High Availability Infrastructure">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-41-create-automatic-failover-manager" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 4.1: Create Automatic Failover Manager
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-42-create-point-in-time-recovery-foundation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 4.2: Create Point-in-Time Recovery Foundation
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-5-ecosystem-packaging" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 5: Ecosystem Packaging
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 5: Ecosystem Packaging">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-51-create-dockerfile" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 5.1: Create Dockerfile
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-52-create-github-actions-cicd" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 5.2: Create GitHub Actions CI/CD
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-53-create-package-registry-configuration" class="md-nav__link">
    <span class="md-ellipsis">
      
        Task 5.3: Create Package Registry Configuration
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#docker" class="md-nav__link">
    <span class="md-ellipsis">
      
        Docker
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build-from-source" class="md-nav__link">
    <span class="md-ellipsis">
      
        Build from Source
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#summary-checklist" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary Checklist
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Summary Checklist">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#phase-1-gpu-modular-refactor" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 1: GPU Modular Refactor
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#phase-2-documentation-infrastructure_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 2: Documentation Infrastructure
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#phase-3-competitive-benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 3: Competitive Benchmarks
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#phase-4-high-availability" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 4: High Availability
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#phase-5-ecosystem-packaging_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        Phase 5: Ecosystem Packaging
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="comprehensive-roadmap-implementation-plan">Comprehensive Roadmap Implementation Plan</h1>
<blockquote>
<p><strong>Codebase Status:</strong> Synced with repository as of 2026-01-18.</p>
<p><strong>Status:</strong> In Progress ðŸ”„</p>
<p><strong>For Claude:</strong> REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p>
</blockquote>
<p><strong>Goal:</strong> Complete all open ROADMAP items through Q3 2026, including GPU Phase 3 refactor, documentation infrastructure, competitive benchmarks, high availability features, and ecosystem packaging.</p>
<p><strong>Architecture:</strong> Modular implementation in 5 phases - GPU completion, documentation tooling, benchmark framework, HA infrastructure, and packaging/distribution. Each phase is independent and can be executed in parallel.</p>
<p><strong>Tech Stack:</strong> Zig 0.16, Docker, GitHub Actions, autodoc tooling, Prometheus metrics</p>
<hr />
<h2 id="phase-1-gpu-modular-refactor-phase-3-completion">Phase 1: GPU Modular Refactor (Phase 3 Completion)</h2>
<h3 id="task-11-create-dispatcher-integration-for-unifiedzig">Task 1.1: Create Dispatcher Integration for unified.zig</h3>
<p><strong>Files:</strong>
- Modify: <code>src/compute/gpu/unified.zig:206-320</code> (Gpu struct init)
- Modify: <code>src/compute/gpu/unified.zig:476-514</code> (vectorAdd)
- Reference: <code>src/compute/gpu/dispatcher.zig</code></p>
<p><strong>Step 1: Add dispatcher field to Gpu struct</strong></p>
<p>In <code>src/compute/gpu/unified.zig</code>, add the dispatcher import and field:</p>
<pre><code class="language-zig">// Add import after line 41
const dispatcher_mod = @import(&quot;dispatcher.zig&quot;);
pub const KernelDispatcher = dispatcher_mod.KernelDispatcher;
</code></pre>
<p>Add field to Gpu struct (after line 229):</p>
<pre><code class="language-zig">    // Kernel dispatcher for backend execution
    dispatcher: ?KernelDispatcher,
</code></pre>
<p><strong>Step 2: Initialize dispatcher in Gpu.init</strong></p>
<p>In <code>Gpu.init()</code> around line 278, add dispatcher initialization:</p>
<pre><code class="language-zig">        // Initialize kernel dispatcher for active device
        var dispatcher: ?KernelDispatcher = null;
        if (active_device) |device| {
            dispatcher = KernelDispatcher.init(allocator, device.backend, device) catch null;

            // Connect to backend factory if available
            if (dispatcher) |*d| {
                const backend_factory = @import(&quot;backend_factory.zig&quot;);
                if (backend_factory.createVTableBackend(allocator, device.backend)) |bi| {
                    d.setBackendInterface(bi);
                } else |_| {}
            }
        }
</code></pre>
<p>Update the return struct to include dispatcher field.</p>
<p><strong>Step 3: Update deinit to cleanup dispatcher</strong></p>
<p>In <code>Gpu.deinit()</code> around line 316, add:</p>
<pre><code class="language-zig">        // Clean up dispatcher
        if (self.dispatcher) |*d| {
            d.deinit();
        }
</code></pre>
<p><strong>Step 4: Run build to verify compilation</strong></p>
<p>Run: <code>zig build</code>
Expected: Build succeeds with no errors</p>
<p><strong>Step 5: Commit</strong></p>
<pre><code class="language-bash">git add src/compute/gpu/unified.zig
git commit -m &quot;feat(gpu): add KernelDispatcher to unified GPU API&quot;
</code></pre>
<hr />
<h3 id="task-12-integrate-dispatcher-into-vectoradd">Task 1.2: Integrate Dispatcher into vectorAdd</h3>
<p><strong>Files:</strong>
- Modify: <code>src/compute/gpu/unified.zig:476-514</code> (vectorAdd method)</p>
<p><strong>Step 1: Update vectorAdd to use dispatcher</strong></p>
<p>Replace the vectorAdd implementation (lines 478-513) with:</p>
<pre><code class="language-zig">    /// Vector addition: result = a + b
    pub fn vectorAdd(self: *Gpu, a: *Buffer, b: *Buffer, result: *Buffer) !ExecutionResult {
        const device = self.active_device orelse return error.NoActiveDevice;

        var timer = std.time.Timer.start() catch return error.TimerFailed;

        // Try dispatcher-based execution first
        if (self.dispatcher) |*disp| {
            const kernel = disp.getBuiltinKernel(.vector_add) catch null;
            if (kernel) |k| {
                const config = dispatcher_mod.LaunchConfig.for1D(a.elementCount(), 256);
                const exec_result = disp.execute(k, config, .{
                    .buffers = &amp;.{ a, b, result },
                }) catch null;

                if (exec_result) |res| {
                    self.stats.kernels_launched += 1;
                    self.stats.total_execution_time_ns += res.execution_time_ns;

                    if (self.metrics) |*m| {
                        m.recordKernel(&quot;vectorAdd&quot;, res.execution_time_ns) catch {};
                    }

                    return ExecutionResult{
                        .execution_time_ns = res.execution_time_ns,
                        .elements_processed = res.elements_processed,
                        .bytes_transferred = res.bytes_transferred,
                        .backend = device.backend,
                        .device_id = device.id,
                    };
                }
            }
        }

        // Fallback to host computation
        if (a.host_data != null and b.host_data != null and result.host_data != null) {
            const a_data = std.mem.bytesAsSlice(f32, a.host_data.?);
            const b_data = std.mem.bytesAsSlice(f32, b.host_data.?);
            var r_data = std.mem.bytesAsSlice(f32, result.host_data.?);

            const len = @min(a_data.len, @min(b_data.len, r_data.len));
            for (0..len) |i| {
                r_data[i] = a_data[i] + b_data[i];
            }

            result.markHostDirty();
        }

        const elapsed = timer.read();
        self.stats.kernels_launched += 1;
        self.stats.total_execution_time_ns += elapsed;

        if (self.metrics) |*m| {
            m.recordKernel(&quot;vectorAdd&quot;, elapsed) catch {};
        }

        return ExecutionResult{
            .execution_time_ns = elapsed,
            .elements_processed = a.elementCount(),
            .bytes_transferred = a.getSize() + b.getSize() + result.getSize(),
            .backend = device.backend,
            .device_id = device.id,
        };
    }
</code></pre>
<p><strong>Step 2: Run tests to verify</strong></p>
<p>Run: <code>zig build test --summary all</code>
Expected: All 51+ tests pass</p>
<p><strong>Step 3: Commit</strong></p>
<pre><code class="language-bash">git add src/compute/gpu/unified.zig
git commit -m &quot;feat(gpu): integrate dispatcher into vectorAdd with fallback&quot;
</code></pre>
<hr />
<h3 id="task-13-integrate-dispatcher-into-remaining-operations">Task 1.3: Integrate Dispatcher into Remaining Operations</h3>
<p><strong>Files:</strong>
- Modify: <code>src/compute/gpu/unified.zig:516-688</code> (matrixMultiply, reduceSum, dotProduct, softmax)</p>
<p><strong>Step 1: Update matrixMultiply</strong></p>
<p>Apply same pattern as vectorAdd - try dispatcher first, fallback to host computation.</p>
<p><strong>Step 2: Update reduceSum</strong></p>
<p>Apply same pattern with <code>.reduce_sum</code> builtin kernel.</p>
<p><strong>Step 3: Update dotProduct</strong></p>
<p>Apply same pattern with <code>.dot_product</code> builtin kernel.</p>
<p><strong>Step 4: Update softmax</strong></p>
<p>Apply same pattern with <code>.softmax</code> builtin kernel.</p>
<p><strong>Step 5: Run tests</strong></p>
<p>Run: <code>zig build test --summary all</code>
Expected: All tests pass</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/compute/gpu/unified.zig
git commit -m &quot;feat(gpu): integrate dispatcher into all GPU operations&quot;
</code></pre>
<hr />
<h3 id="task-14-reduce-modzig-exports">Task 1.4: Reduce mod.zig Exports</h3>
<p><strong>Files:</strong>
- Modify: <code>src/compute/gpu/mod.zig</code></p>
<p><strong>Step 1: Audit current exports</strong></p>
<p>Read <code>src/compute/gpu/mod.zig</code> and identify:
- Public API exports (keep)
- Internal implementation details (make private or remove)</p>
<p><strong>Step 2: Organize exports into categories</strong></p>
<pre><code class="language-zig">//! GPU Compute Module
//!
//! ## Public API
//! - `Gpu` - Main unified GPU interface
//! - `Backend` - Backend type enum
//! - `Device` - Device information
//!
//! ## Internal (use with caution)
//! - `KernelDispatcher` - Low-level kernel dispatch
//! - `BackendFactory` - Backend instantiation

// Public API
pub const unified = @import(&quot;unified.zig&quot;);
pub const Gpu = unified.Gpu;
pub const Backend = @import(&quot;backend.zig&quot;).Backend;
pub const Device = @import(&quot;device.zig&quot;).Device;

// Re-export common types
pub const Buffer = unified.Buffer;
pub const BufferOptions = unified.BufferOptions;
pub const ExecutionResult = unified.ExecutionResult;
pub const GpuConfig = unified.GpuConfig;

// Internal modules (explicitly marked)
pub const internal = struct {
    pub const dispatcher = @import(&quot;dispatcher.zig&quot;);
    pub const backend_factory = @import(&quot;backend_factory.zig&quot;);
    pub const builtin_kernels = @import(&quot;builtin_kernels.zig&quot;);
};
</code></pre>
<p><strong>Step 3: Update dependent imports</strong></p>
<p>Search for any code importing removed exports and update paths.</p>
<p><strong>Step 4: Run build and tests</strong></p>
<p>Run: <code>zig build test --summary all</code>
Expected: All tests pass</p>
<p><strong>Step 5: Commit</strong></p>
<pre><code class="language-bash">git add src/compute/gpu/mod.zig
git commit -m &quot;refactor(gpu): organize exports with clear public/internal separation&quot;
</code></pre>
<hr />
<h3 id="task-15-update-plan-document">Task 1.5: Update Plan Document</h3>
<p><strong>Files:</strong>
- Modify: <code>docs/plans/2026-01-17-modular-codebase-refactor.md</code></p>
<p><strong>Step 1: Mark Phase 3 complete</strong></p>
<p>Update status to "Complete (Phase 1, 2 &amp; 3)" and check off remaining items.</p>
<p><strong>Step 2: Commit</strong></p>
<pre><code class="language-bash">git add docs/plans/2026-01-17-modular-codebase-refactor.md
git commit -m &quot;docs: mark GPU modular refactor Phase 3 complete&quot;
</code></pre>
<hr />
<h2 id="phase-2-documentation-infrastructure">Phase 2: Documentation Infrastructure</h2>
<h3 id="task-21-create-api-documentation-generator-script">Task 2.1: Create API Documentation Generator Script</h3>
<p><strong>Files:</strong>
- Create: <code>tools/gendocs.zig</code>
- Create: <code>docs/api/README.md</code></p>
<p><strong>Step 1: Create documentation generator</strong></p>
<pre><code class="language-zig">//! API Documentation Generator
//!
//! Generates markdown documentation from Zig doc comments.
//! Usage: zig build run-gendocs

const std = @import(&quot;std&quot;);

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    const output_dir = if (args.len &gt; 1) args[1] else &quot;docs/api&quot;;

    // Generate docs for main modules
    const modules = [_][]const u8{
        &quot;src/abi.zig&quot;,
        &quot;src/compute/gpu/unified.zig&quot;,
        &quot;src/features/ai/mod.zig&quot;,
        &quot;src/features/database/mod.zig&quot;,
    };

    for (modules) |module| {
        try generateModuleDoc(allocator, module, output_dir);
    }

    std.debug.print(&quot;Documentation generated in {s}\n&quot;, .{output_dir});
}

fn generateModuleDoc(allocator: std.mem.Allocator, module_path: []const u8, output_dir: []const u8) !void {
    // Read source file
    const source = std.fs.cwd().readFileAlloc(allocator, module_path, 1024 * 1024) catch |err| {
        std.debug.print(&quot;Warning: Could not read {s}: {}\n&quot;, .{ module_path, err });
        return;
    };
    defer allocator.free(source);

    // Extract module name
    const basename = std.fs.path.basename(module_path);
    const name = std.mem.sliceTo(basename, '.');

    // Create output file
    const output_path = try std.fmt.allocPrint(allocator, &quot;{s}/{s}.md&quot;, .{ output_dir, name });
    defer allocator.free(output_path);

    var file = try std.fs.cwd().createFile(output_path, .{});
    defer file.close();

    var writer = file.writer();

    // Write header
    try writer.print(&quot;# {s} Module\n\n&quot;, .{name});
    try writer.print(&quot;**Source:** `{s}`\n\n&quot;, .{module_path});

    // Extract and write doc comments
    try extractDocComments(source, writer);
}

fn extractDocComments(source: []const u8, writer: anytype) !void {
    var lines = std.mem.splitScalar(u8, source, '\n');
    var in_doc_block = false;

    while (lines.next()) |line| {
        const trimmed = std.mem.trim(u8, line, &quot; \t&quot;);

        if (std.mem.startsWith(u8, trimmed, &quot;//!&quot;)) {
            // Module-level doc comment
            const content = if (trimmed.len &gt; 3) trimmed[3..] else &quot;&quot;;
            try writer.print(&quot;{s}\n&quot;, .{std.mem.trim(u8, content, &quot; &quot;)});
            in_doc_block = true;
        } else if (std.mem.startsWith(u8, trimmed, &quot;///&quot;)) {
            // Item-level doc comment
            const content = if (trimmed.len &gt; 3) trimmed[3..] else &quot;&quot;;
            try writer.print(&quot;{s}\n&quot;, .{std.mem.trim(u8, content, &quot; &quot;)});
        } else if (in_doc_block and trimmed.len == 0) {
            try writer.writeAll(&quot;\n&quot;);
        } else {
            in_doc_block = false;
        }
    }
}
</code></pre>
<p><strong>Step 2: Add build target</strong></p>
<p>In <code>build.zig</code>, add:</p>
<pre><code class="language-zig">const gendocs = b.addExecutable(.{
    .name = &quot;gendocs&quot;,
    .root_source_file = b.path(&quot;tools/gendocs.zig&quot;),
    .target = target,
    .optimize = optimize,
});
const run_gendocs = b.addRunArtifact(gendocs);
const gendocs_step = b.step(&quot;gendocs&quot;, &quot;Generate API documentation&quot;);
gendocs_step.dependOn(&amp;run_gendocs.step);
</code></pre>
<p><strong>Step 3: Create docs/api directory structure</strong></p>
<pre><code class="language-bash">mkdir -p docs/api
</code></pre>
<p><strong>Step 4: Run and verify</strong></p>
<p>Run: <code>zig build gendocs</code>
Expected: Documentation files created in docs/api/</p>
<p><strong>Step 5: Commit</strong></p>
<pre><code class="language-bash">git add tools/gendocs.zig docs/api/
git commit -m &quot;feat(docs): add API documentation generator&quot;
</code></pre>
<hr />
<h3 id="task-22-create-architecture-diagram-sources">Task 2.2: Create Architecture Diagram Sources</h3>
<p><strong>Files:</strong>
- Create: <code>docs/diagrams/system-architecture.md</code>
- Create: <code>docs/diagrams/gpu-architecture.md</code>
- Create: <code>docs/diagrams/data-flow.md</code></p>
<p><strong>Step 1: Create system architecture diagram (Mermaid)</strong></p>
<pre><code class="language-markdown"># System Architecture

```mermaid
graph TB
    subgraph &quot;Public API&quot;
        ABI[abi.zig]
    end

    subgraph &quot;Framework Layer&quot;
        FW[Framework]
        LC[Lifecycle]
    end

    subgraph &quot;Feature Layer&quot;
        AI[AI/LLM]
        DB[Database]
        GPU[GPU Compute]
        NET[Network]
    end

    subgraph &quot;Compute Layer&quot;
        RT[Runtime]
        CONC[Concurrency]
        MEM[Memory]
    end

    subgraph &quot;Shared Layer&quot;
        LOG[Logging]
        SEC[Security]
        UTIL[Utilities]
    end

    ABI --&gt; FW
    FW --&gt; AI
    FW --&gt; DB
    FW --&gt; GPU
    FW --&gt; NET
    AI --&gt; RT
    GPU --&gt; RT
    RT --&gt; CONC
    RT --&gt; MEM
    AI --&gt; LOG
    DB --&gt; LOG
    GPU --&gt; LOG
</code></pre>
<pre><code>
**Step 2: Create GPU architecture diagram**

```markdown
# GPU Architecture

```mermaid
graph TB
    subgraph &quot;Unified API&quot;
        GPU[Gpu struct]
        BUF[Buffer]
    end

    subgraph &quot;Dispatch Layer&quot;
        DISP[KernelDispatcher]
        KERN[BuiltinKernels]
    end

    subgraph &quot;Backend Factory&quot;
        FACT[BackendFactory]
    end

    subgraph &quot;VTable Backends&quot;
        CUDA[CUDA VTable]
        VK[Vulkan VTable]
        MTL[Metal VTable]
        WGPU[WebGPU VTable]
        SIM[Simulated CPU]
    end

    GPU --&gt; DISP
    GPU --&gt; BUF
    DISP --&gt; KERN
    DISP --&gt; FACT
    FACT --&gt; CUDA
    FACT --&gt; VK
    FACT --&gt; MTL
    FACT --&gt; WGPU
    FACT --&gt; SIM
</code></pre>
<pre><code>
**Step 3: Create data flow diagram**

```markdown
# Data Flow

```mermaid
sequenceDiagram
    participant User
    participant Gpu
    participant Dispatcher
    participant Backend
    participant Device

    User-&gt;&gt;Gpu: createBuffer(data)
    Gpu-&gt;&gt;Gpu: allocate host memory
    Gpu--&gt;&gt;User: Buffer

    User-&gt;&gt;Gpu: vectorAdd(a, b, result)
    Gpu-&gt;&gt;Dispatcher: getBuiltinKernel(.vector_add)
    Dispatcher-&gt;&gt;Dispatcher: check cache
    Dispatcher-&gt;&gt;Backend: compileKernel(source)
    Backend--&gt;&gt;Dispatcher: kernel handle

    Dispatcher-&gt;&gt;Backend: launchKernel(handle, config, args)
    Backend-&gt;&gt;Device: execute on GPU
    Device--&gt;&gt;Backend: complete
    Backend--&gt;&gt;Dispatcher: success
    Dispatcher--&gt;&gt;Gpu: ExecutionResult
    Gpu--&gt;&gt;User: ExecutionResult
</code></pre>
<pre><code>
**Step 4: Commit**

```bash
git add docs/diagrams/
git commit -m &quot;docs: add architecture diagrams in Mermaid format&quot;
</code></pre>
<hr />
<h2 id="phase-3-competitive-benchmark-framework">Phase 3: Competitive Benchmark Framework</h2>
<h3 id="task-31-create-benchmark-runner-infrastructure">Task 3.1: Create Benchmark Runner Infrastructure</h3>
<p><strong>Files:</strong>
- Create: <code>benchmarks/competitive/runner.zig</code>
- Create: <code>benchmarks/competitive/baselines.json</code></p>
<p><strong>Step 1: Create benchmark runner</strong></p>
<pre><code class="language-zig">//! Competitive Benchmark Runner
//!
//! Compares ABI performance against reference implementations.

const std = @import(&quot;std&quot;);
const abi = @import(&quot;abi&quot;);

pub const BenchmarkResult = struct {
    name: []const u8,
    abi_time_ns: u64,
    baseline_time_ns: ?u64,
    elements: usize,
    throughput_gbps: f64,
    speedup: ?f64,

    pub fn format(self: BenchmarkResult, writer: anytype) !void {
        try writer.print(&quot;{s:&lt;30} &quot;, .{self.name});
        try writer.print(&quot;{d:&gt;10.2} ms &quot;, .{@as(f64, @floatFromInt(self.abi_time_ns)) / 1_000_000.0});
        try writer.print(&quot;{d:&gt;8.2} GB/s &quot;, .{self.throughput_gbps});
        if (self.speedup) |s| {
            try writer.print(&quot;{d:&gt;6.2}x&quot;, .{s});
        }
        try writer.writeAll(&quot;\n&quot;);
    }
};

pub const BenchmarkSuite = struct {
    allocator: std.mem.Allocator,
    results: std.ArrayListUnmanaged(BenchmarkResult),
    baselines: std.json.ObjectMap,

    pub fn init(allocator: std.mem.Allocator) !BenchmarkSuite {
        // Load baselines from JSON
        var baselines = std.json.ObjectMap.init(allocator);

        const baseline_path = &quot;benchmarks/competitive/baselines.json&quot;;
        if (std.fs.cwd().readFileAlloc(allocator, baseline_path, 1024 * 1024)) |content| {
            defer allocator.free(content);
            if (std.json.parseFromSlice(std.json.Value, allocator, content, .{})) |parsed| {
                if (parsed.value == .object) {
                    baselines = parsed.value.object;
                }
            } else |_| {}
        } else |_| {}

        return .{
            .allocator = allocator,
            .results = .empty,
            .baselines = baselines,
        };
    }

    pub fn deinit(self: *BenchmarkSuite) void {
        self.results.deinit(self.allocator);
    }

    pub fn run(self: *BenchmarkSuite, name: []const u8, func: *const fn () u64, elements: usize, bytes: usize) !void {
        // Warmup
        _ = func();
        _ = func();

        // Measure
        const iterations = 10;
        var total_ns: u64 = 0;

        for (0..iterations) |_| {
            total_ns += func();
        }

        const avg_ns = total_ns / iterations;
        const throughput = @as(f64, @floatFromInt(bytes)) / (@as(f64, @floatFromInt(avg_ns)) / 1_000_000_000.0) / (1024 * 1024 * 1024);

        var baseline_ns: ?u64 = null;
        var speedup: ?f64 = null;

        if (self.baselines.get(name)) |b| {
            if (b == .integer) {
                baseline_ns = @intCast(b.integer);
                speedup = @as(f64, @floatFromInt(baseline_ns.?)) / @as(f64, @floatFromInt(avg_ns));
            }
        }

        try self.results.append(self.allocator, .{
            .name = name,
            .abi_time_ns = avg_ns,
            .baseline_time_ns = baseline_ns,
            .elements = elements,
            .throughput_gbps = throughput,
            .speedup = speedup,
        });
    }

    pub fn printReport(self: *const BenchmarkSuite) void {
        std.debug.print(&quot;\n{'='*60}\n&quot;, .{});
        std.debug.print(&quot;ABI Competitive Benchmark Report\n&quot;, .{});
        std.debug.print(&quot;{'='*60}\n\n&quot;, .{});

        std.debug.print(&quot;{s:&lt;30} {s:&gt;12} {s:&gt;10} {s:&gt;8}\n&quot;, .{ &quot;Benchmark&quot;, &quot;Time&quot;, &quot;Throughput&quot;, &quot;Speedup&quot; });
        std.debug.print(&quot;{'-'*60}\n&quot;, .{});

        for (self.results.items) |result| {
            result.format(std.io.getStdErr().writer()) catch {};
        }
    }
};
</code></pre>
<p><strong>Step 2: Create baselines JSON</strong></p>
<pre><code class="language-json">{
    &quot;vector_add_1m&quot;: 500000,
    &quot;matrix_multiply_1k&quot;: 50000000,
    &quot;reduce_sum_1m&quot;: 200000,
    &quot;softmax_64k&quot;: 100000
}
</code></pre>
<p><strong>Step 3: Commit</strong></p>
<pre><code class="language-bash">git add benchmarks/competitive/
git commit -m &quot;feat(bench): add competitive benchmark framework&quot;
</code></pre>
<hr />
<h3 id="task-32-implement-vector-operation-benchmarks">Task 3.2: Implement Vector Operation Benchmarks</h3>
<p><strong>Files:</strong>
- Create: <code>benchmarks/competitive/vector_ops.zig</code></p>
<p><strong>Step 1: Create vector benchmarks</strong></p>
<pre><code class="language-zig">//! Vector Operation Benchmarks

const std = @import(&quot;std&quot;);
const abi = @import(&quot;abi&quot;);
const runner = @import(&quot;runner.zig&quot;);

pub fn runVectorBenchmarks(suite: *runner.BenchmarkSuite, gpu: *abi.Gpu) !void {
    // 1M element vector add
    const size_1m = 1_000_000;
    var a_data: [size_1m]f32 = undefined;
    var b_data: [size_1m]f32 = undefined;

    // Initialize with random data
    var prng = std.Random.DefaultPrng.init(42);
    const random = prng.random();
    for (0..size_1m) |i| {
        a_data[i] = random.float(f32);
        b_data[i] = random.float(f32);
    }

    const a = try gpu.createBufferFromSlice(f32, &amp;a_data, .{});
    defer gpu.destroyBuffer(a);
    const b = try gpu.createBufferFromSlice(f32, &amp;b_data, .{});
    defer gpu.destroyBuffer(b);
    const result = try gpu.createBuffer(size_1m * @sizeOf(f32), .{});
    defer gpu.destroyBuffer(result);

    try suite.run(&quot;vector_add_1m&quot;, struct {
        fn bench() u64 {
            var timer = std.time.Timer.start() catch return 0;
            _ = gpu.vectorAdd(a, b, result) catch {};
            return timer.read();
        }
    }.bench, size_1m, size_1m * @sizeOf(f32) * 3);
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var suite = try runner.BenchmarkSuite.init(allocator);
    defer suite.deinit();

    var gpu = try abi.Gpu.init(allocator, .{});
    defer gpu.deinit();

    if (!gpu.isAvailable()) {
        std.debug.print(&quot;No GPU available, skipping benchmarks\n&quot;, .{});
        return;
    }

    try runVectorBenchmarks(&amp;suite, &amp;gpu);

    suite.printReport();
}
</code></pre>
<p><strong>Step 2: Commit</strong></p>
<pre><code class="language-bash">git add benchmarks/competitive/vector_ops.zig
git commit -m &quot;feat(bench): add vector operation benchmarks&quot;
</code></pre>
<hr />
<h2 id="phase-4-high-availability-infrastructure">Phase 4: High Availability Infrastructure</h2>
<h3 id="task-41-create-automatic-failover-manager">Task 4.1: Create Automatic Failover Manager</h3>
<p><strong>Files:</strong>
- Create: <code>src/features/network/failover.zig</code>
- Modify: <code>src/features/network/mod.zig</code></p>
<p><strong>Step 1: Create failover manager</strong></p>
<pre><code class="language-zig">//! Automatic Failover Manager
//!
//! Monitors node health and triggers automatic failover when primary fails.

const std = @import(&quot;std&quot;);
const loadbalancer = @import(&quot;loadbalancer.zig&quot;);

pub const FailoverConfig = struct {
    /// Health check interval in milliseconds.
    health_check_interval_ms: u64 = 5000,
    /// Number of failed checks before triggering failover.
    failure_threshold: u32 = 3,
    /// Timeout for health checks in milliseconds.
    health_check_timeout_ms: u64 = 2000,
    /// Enable automatic failover.
    auto_failover: bool = true,
};

pub const FailoverState = enum {
    normal,
    monitoring,
    failing_over,
    failed_over,
    recovering,
};

pub const FailoverEvent = struct {
    timestamp_ms: i64,
    event_type: EventType,
    node_id: []const u8,
    details: ?[]const u8,

    pub const EventType = enum {
        health_check_failed,
        failover_started,
        failover_completed,
        recovery_started,
        recovery_completed,
    };
};

pub const FailoverManager = struct {
    allocator: std.mem.Allocator,
    config: FailoverConfig,
    state: FailoverState,
    primary_node: ?[]const u8,
    secondary_nodes: std.ArrayListUnmanaged([]const u8),
    failure_counts: std.StringHashMapUnmanaged(u32),
    event_log: std.ArrayListUnmanaged(FailoverEvent),
    mutex: std.Thread.Mutex,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, config: FailoverConfig) Self {
        return .{
            .allocator = allocator,
            .config = config,
            .state = .normal,
            .primary_node = null,
            .secondary_nodes = .empty,
            .failure_counts = .empty,
            .event_log = .empty,
            .mutex = .{},
        };
    }

    pub fn deinit(self: *Self) void {
        self.secondary_nodes.deinit(self.allocator);
        self.failure_counts.deinit(self.allocator);
        self.event_log.deinit(self.allocator);
    }

    pub fn setPrimary(self: *Self, node_id: []const u8) !void {
        self.mutex.lock();
        defer self.mutex.unlock();
        self.primary_node = try self.allocator.dupe(u8, node_id);
    }

    pub fn addSecondary(self: *Self, node_id: []const u8) !void {
        self.mutex.lock();
        defer self.mutex.unlock();
        const id = try self.allocator.dupe(u8, node_id);
        try self.secondary_nodes.append(self.allocator, id);
    }

    pub fn recordHealthCheckResult(self: *Self, node_id: []const u8, success: bool) !void {
        self.mutex.lock();
        defer self.mutex.unlock();

        if (success) {
            _ = self.failure_counts.remove(node_id);
            return;
        }

        // Increment failure count
        const entry = try self.failure_counts.getOrPut(self.allocator, node_id);
        if (entry.found_existing) {
            entry.value_ptr.* += 1;
        } else {
            entry.value_ptr.* = 1;
        }

        // Check if failover needed
        if (entry.value_ptr.* &gt;= self.config.failure_threshold) {
            if (self.config.auto_failover and
                self.primary_node != null and
                std.mem.eql(u8, self.primary_node.?, node_id))
            {
                try self.triggerFailover(node_id);
            }
        }
    }

    fn triggerFailover(self: *Self, failed_node: []const u8) !void {
        self.state = .failing_over;

        try self.logEvent(.{
            .timestamp_ms = std.time.milliTimestamp(),
            .event_type = .failover_started,
            .node_id = failed_node,
            .details = &quot;Primary node failed, initiating failover&quot;,
        });

        // Promote first available secondary
        if (self.secondary_nodes.items.len &gt; 0) {
            const new_primary = self.secondary_nodes.orderedRemove(0);
            self.primary_node = new_primary;
            self.state = .failed_over;

            try self.logEvent(.{
                .timestamp_ms = std.time.milliTimestamp(),
                .event_type = .failover_completed,
                .node_id = new_primary,
                .details = &quot;Promoted to primary&quot;,
            });
        } else {
            self.state = .normal; // No secondaries available
        }
    }

    fn logEvent(self: *Self, event: FailoverEvent) !void {
        try self.event_log.append(self.allocator, event);
    }

    pub fn getState(self: *Self) FailoverState {
        self.mutex.lock();
        defer self.mutex.unlock();
        return self.state;
    }

    pub fn getEventLog(self: *Self) []const FailoverEvent {
        self.mutex.lock();
        defer self.mutex.unlock();
        return self.event_log.items;
    }
};
</code></pre>
<p><strong>Step 2: Export from mod.zig</strong></p>
<p>Add to <code>src/features/network/mod.zig</code>:</p>
<pre><code class="language-zig">pub const failover = @import(&quot;failover.zig&quot;);
pub const FailoverManager = failover.FailoverManager;
pub const FailoverConfig = failover.FailoverConfig;
</code></pre>
<p><strong>Step 3: Write test</strong></p>
<pre><code class="language-zig">test &quot;FailoverManager basic operations&quot; {
    var fm = FailoverManager.init(std.testing.allocator, .{
        .failure_threshold = 2,
        .auto_failover = true,
    });
    defer fm.deinit();

    try fm.setPrimary(&quot;node-1&quot;);
    try fm.addSecondary(&quot;node-2&quot;);

    // First failure - no failover yet
    try fm.recordHealthCheckResult(&quot;node-1&quot;, false);
    try std.testing.expectEqual(FailoverState.normal, fm.getState());

    // Second failure - triggers failover
    try fm.recordHealthCheckResult(&quot;node-1&quot;, false);
    try std.testing.expectEqual(FailoverState.failed_over, fm.getState());
}
</code></pre>
<p><strong>Step 4: Run tests</strong></p>
<p>Run: <code>zig build test --summary all</code>
Expected: All tests pass including new failover test</p>
<p><strong>Step 5: Commit</strong></p>
<pre><code class="language-bash">git add src/features/network/failover.zig src/features/network/mod.zig
git commit -m &quot;feat(ha): add automatic failover manager&quot;
</code></pre>
<hr />
<h3 id="task-42-create-point-in-time-recovery-foundation">Task 4.2: Create Point-in-Time Recovery Foundation</h3>
<p><strong>Files:</strong>
- Create: <code>src/features/database/recovery.zig</code></p>
<p><strong>Step 1: Create recovery manager</strong></p>
<pre><code class="language-zig">//! Point-in-Time Recovery
//!
//! Enables database recovery to any point in time using WAL segments.

const std = @import(&quot;std&quot;);

pub const RecoveryPoint = struct {
    timestamp_ms: i64,
    wal_segment: u64,
    offset: u64,
    checksum: u32,
};

pub const RecoveryConfig = struct {
    /// Directory for WAL segments.
    wal_dir: []const u8 = &quot;wal&quot;,
    /// Maximum WAL retention in hours.
    retention_hours: u32 = 168, // 7 days
    /// Segment size in bytes.
    segment_size: usize = 16 * 1024 * 1024, // 16MB
};

pub const RecoveryManager = struct {
    allocator: std.mem.Allocator,
    config: RecoveryConfig,
    recovery_points: std.ArrayListUnmanaged(RecoveryPoint),
    current_segment: u64,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, config: RecoveryConfig) Self {
        return .{
            .allocator = allocator,
            .config = config,
            .recovery_points = .empty,
            .current_segment = 0,
        };
    }

    pub fn deinit(self: *Self) void {
        self.recovery_points.deinit(self.allocator);
    }

    pub fn createRecoveryPoint(self: *Self) !RecoveryPoint {
        const point = RecoveryPoint{
            .timestamp_ms = std.time.milliTimestamp(),
            .wal_segment = self.current_segment,
            .offset = 0, // Would be actual offset in production
            .checksum = 0, // Would be computed checksum
        };
        try self.recovery_points.append(self.allocator, point);
        return point;
    }

    pub fn findRecoveryPoint(self: *Self, target_timestamp_ms: i64) ?RecoveryPoint {
        // Find closest recovery point before target
        var best: ?RecoveryPoint = null;
        for (self.recovery_points.items) |point| {
            if (point.timestamp_ms &lt;= target_timestamp_ms) {
                if (best == null or point.timestamp_ms &gt; best.?.timestamp_ms) {
                    best = point;
                }
            }
        }
        return best;
    }

    pub fn recoverTo(self: *Self, point: RecoveryPoint) !void {
        _ = self;
        // In production: replay WAL from point.wal_segment:point.offset
        std.log.info(&quot;Recovering to segment {} offset {}&quot;, .{ point.wal_segment, point.offset });
    }

    pub fn listRecoveryPoints(self: *const Self) []const RecoveryPoint {
        return self.recovery_points.items;
    }
};
</code></pre>
<p><strong>Step 2: Commit</strong></p>
<pre><code class="language-bash">git add src/features/database/recovery.zig
git commit -m &quot;feat(ha): add point-in-time recovery foundation&quot;
</code></pre>
<hr />
<h2 id="phase-5-ecosystem-packaging">Phase 5: Ecosystem Packaging</h2>
<h3 id="task-51-create-dockerfile">Task 5.1: Create Dockerfile</h3>
<p><strong>Files:</strong>
- Create: <code>Dockerfile</code>
- Create: <code>.dockerignore</code></p>
<p><strong>Step 1: Create Dockerfile</strong></p>
<pre><code class="language-dockerfile"># ABI Framework Docker Image
# Multi-stage build for minimal image size

# Build stage
FROM debian:bookworm-slim AS builder

# Install Zig
RUN apt-get update &amp;&amp; apt-get install -y \
    curl \
    xz-utils \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

ARG ZIG_VERSION=0.16.0
RUN curl -L https://ziglang.org/download/${ZIG_VERSION}/zig-linux-x86_64-${ZIG_VERSION}.tar.xz | tar -xJ -C /opt \
    &amp;&amp; ln -s /opt/zig-linux-x86_64-${ZIG_VERSION}/zig /usr/local/bin/zig

# Build ABI
WORKDIR /build
COPY . .
RUN zig build -Doptimize=ReleaseFast

# Runtime stage
FROM debian:bookworm-slim

# Install runtime dependencies
RUN apt-get update &amp;&amp; apt-get install -y \
    ca-certificates \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Copy built binary
COPY --from=builder /build/zig-out/bin/abi /usr/local/bin/abi

# Create non-root user
RUN useradd -m -s /bin/bash abi
USER abi
WORKDIR /home/abi

# Default command
ENTRYPOINT [&quot;abi&quot;]
CMD [&quot;--help&quot;]

# Labels
LABEL org.opencontainers.image.title=&quot;ABI Framework&quot;
LABEL org.opencontainers.image.description=&quot;High-performance AI/ML framework in Zig&quot;
LABEL org.opencontainers.image.version=&quot;0.6.0&quot;
</code></pre>
<p><strong>Step 2: Create .dockerignore</strong></p>
<pre><code>.git
.zig-cache
zig-out
*.o
*.a
.DS_Store
*.log
testingllm.ckpt/
backups/
</code></pre>
<p><strong>Step 3: Test build</strong></p>
<p>Run: <code>docker build -t abi:latest .</code>
Expected: Image builds successfully</p>
<p><strong>Step 4: Commit</strong></p>
<pre><code class="language-bash">git add Dockerfile .dockerignore
git commit -m &quot;feat(docker): add multi-stage Dockerfile&quot;
</code></pre>
<hr />
<h3 id="task-52-create-github-actions-cicd">Task 5.2: Create GitHub Actions CI/CD</h3>
<p><strong>Files:</strong>
- Create: <code>.github/workflows/ci.yml</code>
- Create: <code>.github/workflows/release.yml</code></p>
<p><strong>Step 1: Create CI workflow</strong></p>
<pre><code class="language-yaml">name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Zig
        uses: goto-bus-stop/setup-zig@v2
        with:
          version: 0.16.0

      - name: Build
        run: zig build

      - name: Test
        run: zig build test --summary all

      - name: Format Check
        run: zig fmt --check .

  docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build Docker Image
        run: docker build -t abi:ci .

      - name: Test Docker Image
        run: docker run --rm abi:ci --version
</code></pre>
<p><strong>Step 2: Create release workflow</strong></p>
<pre><code class="language-yaml">name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Zig
        uses: goto-bus-stop/setup-zig@v2
        with:
          version: 0.16.0

      - name: Build Release
        run: zig build -Doptimize=ReleaseFast

      - name: Create Tarball
        run: |
          mkdir -p dist
          tar -czvf dist/abi-${{ github.ref_name }}-linux-x86_64.tar.gz \
            -C zig-out/bin abi

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: abi-release
          path: dist/

      - name: Docker Build &amp; Push
        uses: docker/build-push-action@v5
        with:
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:${{ github.ref_name }}
            ghcr.io/${{ github.repository }}:latest
</code></pre>
<p><strong>Step 3: Commit</strong></p>
<pre><code class="language-bash">git add .github/workflows/
git commit -m &quot;ci: add GitHub Actions workflows for CI and releases&quot;
</code></pre>
<hr />
<h3 id="task-53-create-package-registry-configuration">Task 5.3: Create Package Registry Configuration</h3>
<p><strong>Files:</strong>
- Create: <code>build.zig.zon</code>
- Modify: <code>README.md</code> (add installation instructions)</p>
<p><strong>Step 1: Create build.zig.zon for Zig package registry</strong></p>
<pre><code class="language-zig">.{
    .name = &quot;abi&quot;,
    .version = &quot;0.6.0&quot;,
    .paths = .{
        &quot;build.zig&quot;,
        &quot;build.zig.zon&quot;,
        &quot;src&quot;,
        &quot;tools&quot;,
        &quot;benchmarks&quot;,
        &quot;docs&quot;,
        &quot;LICENSE&quot;,
        &quot;README.md&quot;,
    },
    .dependencies = .{},
}
</code></pre>
<p><strong>Step 2: Update README with installation</strong></p>
<p>Add to README.md:</p>
<pre><code class="language-markdown">## Installation

### Zig Package Manager

Add to your `build.zig.zon`:

```zig
.dependencies = .{
    .abi = .{
        .url = &quot;https://github.com/your-org/abi/archive/v0.6.0.tar.gz&quot;,
        .hash = &quot;...&quot;,
    },
},
</code></pre>
<h3 id="docker">Docker</h3>
<pre><code class="language-bash">docker pull ghcr.io/your-org/abi:latest
docker run --rm abi --help
</code></pre>
<h3 id="build-from-source">Build from Source</h3>
<pre><code class="language-bash">git clone https://github.com/your-org/abi.git
cd abi
zig build -Doptimize=ReleaseFast
</code></pre>
<pre><code>
**Step 3: Commit**

```bash
git add build.zig.zon README.md
git commit -m &quot;feat(package): add Zig package registry configuration&quot;
</code></pre>
<hr />
<h2 id="summary-checklist">Summary Checklist</h2>
<h3 id="phase-1-gpu-modular-refactor">Phase 1: GPU Modular Refactor</h3>
<ul>
<li>[ ] Task 1.1: Add dispatcher to Gpu struct</li>
<li>[ ] Task 1.2: Integrate dispatcher into vectorAdd</li>
<li>[ ] Task 1.3: Integrate dispatcher into remaining operations</li>
<li>[ ] Task 1.4: Reduce mod.zig exports</li>
<li>[ ] Task 1.5: Update plan document</li>
</ul>
<h3 id="phase-2-documentation-infrastructure_1">Phase 2: Documentation Infrastructure</h3>
<ul>
<li>[ ] Task 2.1: Create API documentation generator</li>
<li>[ ] Task 2.2: Create architecture diagrams</li>
</ul>
<h3 id="phase-3-competitive-benchmarks">Phase 3: Competitive Benchmarks</h3>
<ul>
<li>[ ] Task 3.1: Create benchmark runner infrastructure</li>
<li>[ ] Task 3.2: Implement vector operation benchmarks</li>
</ul>
<h3 id="phase-4-high-availability">Phase 4: High Availability</h3>
<ul>
<li>[ ] Task 4.1: Create automatic failover manager</li>
<li>[ ] Task 4.2: Create point-in-time recovery foundation</li>
</ul>
<h3 id="phase-5-ecosystem-packaging_1">Phase 5: Ecosystem Packaging</h3>
<ul>
<li>[ ] Task 5.1: Create Dockerfile</li>
<li>[ ] Task 5.2: Create GitHub Actions CI/CD</li>
<li>[ ] Task 5.3: Create package registry configuration</li>
</ul>
<hr />
<p><strong>Estimated Total Tasks:</strong> 12 major tasks across 5 phases
<strong>Estimated Commits:</strong> 15-20 commits</p>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "navigation.sections"], "search": "../../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>