<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>abbey-aviva-abi-wdbx-framework - ABI Framework Documentation</title>
  <meta name="description" content="">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/abi/assets/css/style.css">
</head>
<body>
<nav class="navbar">
  <div class="nav-container">
    <a href="/abi/" class="nav-logo">
      <span class="logo-text">ABI</span>
      <span class="logo-version">v0.16.0</span>
    </a>
    <div class="nav-links">
      <a href="/abi/">Home</a>
      <a href="/abi/intro.html">Docs</a>
      <a href="https://github.com/donaldfilimon/abi" target="_blank">GitHub</a>
    </div>
    <button class="theme-toggle" onclick="toggleTheme()"><span class="theme-icon">üåô</span></button>
  </div>
</nav>
<div class="main-container">
  <main class="content" style="margin-left: 0;">
    <article class="doc-article">
      <header class="doc-header">
        <h1>abbey-aviva-abi-wdbx-framework</h1>
      </header>
      <nav class="toc"><h3>On this page</h3><ul>
        <li style="padding-left: 0px"><a href="#abbeyavivaabi-multipersona-ai-framework-with-wdbx-architecture">Abbey‚ÄìAviva‚ÄìAbi Multi‚ÄëPersona AI Framework with WDBX Architecture</a></li>
        <li style="padding-left: 16px"><a href="#abstract">Abstract</a></li>
        <li style="padding-left: 16px"><a href="#1-introduction">1. Introduction</a></li>
        <li style="padding-left: 32px"><a href="#11-problem-statement">1.1 Problem Statement</a></li>
        <li style="padding-left: 32px"><a href="#12-contributions">1.2 Contributions</a></li>
        <li style="padding-left: 32px"><a href="#13-design-principles">1.3 Design Principles</a></li>
        <li style="padding-left: 16px"><a href="#2-system-overview">2. System Overview</a></li>
        <li style="padding-left: 32px"><a href="#21-request-lifecycle">2.1 Request Lifecycle</a></li>
        <li style="padding-left: 32px"><a href="#22-control-surfaces">2.2 Control Surfaces</a></li>
        <li style="padding-left: 32px"><a href="#23-data-flow-and-artifacts">2.3 Data Flow and Artifacts</a></li>
        <li style="padding-left: 16px"><a href="#3-persona-design">3. Persona Design</a></li>
        <li style="padding-left: 32px"><a href="#31-abbey-empathetic-polymath">3.1 Abbey: Empathetic Polymath</a></li>
        <li style="padding-left: 32px"><a href="#32-aviva-unfiltered-expert">3.2 Aviva: Unfiltered Expert</a></li>
        <li style="padding-left: 32px"><a href="#33-abi-adaptive-moderator-and-router">3.3 Abi: Adaptive Moderator and Router</a></li>
        <li style="padding-left: 32px"><a href="#34-persona-contracts">3.4 Persona Contracts</a></li>
        <li style="padding-left: 16px"><a href="#4-wdbx-wide-distributed-block-exchange">4. WDBX: Wide Distributed Block Exchange</a></li>
        <li style="padding-left: 32px"><a href="#41-requirements">4.1 Requirements</a></li>
        <li style="padding-left: 32px"><a href="#42-data-model">4.2 Data Model</a></li>
        <li style="padding-left: 32px"><a href="#43-block-chaining-for-continuity">4.3 Block Chaining for Continuity</a></li>
        <li style="padding-left: 32px"><a href="#44-sharding-and-routing">4.4 Sharding and Routing</a></li>
        <li style="padding-left: 32px"><a href="#45-mvcc-for-concurrent-readswrites">4.5 MVCC for Concurrent Reads/Writes</a></li>
        <li style="padding-left: 32px"><a href="#46-retrieval-pipeline">4.6 Retrieval Pipeline</a></li>
        <li style="padding-left: 32px"><a href="#47-compression-and-storage-efficiency">4.7 Compression and Storage Efficiency</a></li>
        <li style="padding-left: 32px"><a href="#48-replication-and-consistency">4.8 Replication and Consistency</a></li>
        <li style="padding-left: 32px"><a href="#49-summarization-blocks-and-memory-hygiene">4.9 Summarization Blocks and Memory Hygiene</a></li>
        <li style="padding-left: 32px"><a href="#410-integrity-and-audit-fields">4.10 Integrity and Audit Fields</a></li>
        <li style="padding-left: 16px"><a href="#5-persona-routing-and-blending">5. Persona Routing and Blending</a></li>
        <li style="padding-left: 32px"><a href="#51-signals">5.1 Signals</a></li>
        <li style="padding-left: 32px"><a href="#52-persona-selection-model">5.2 Persona Selection Model</a></li>
        <li style="padding-left: 32px"><a href="#53-blending-constraints">5.3 Blending Constraints</a></li>
        <li style="padding-left: 32px"><a href="#54-user-override">5.4 User Override</a></li>
        <li style="padding-left: 32px"><a href="#55-explainable-routing">5.5 Explainable Routing</a></li>
        <li style="padding-left: 16px"><a href="#6-training-methodology">6. Training Methodology</a></li>
        <li style="padding-left: 32px"><a href="#61-base-model-and-persona-conditioning">6.1 Base Model and Persona Conditioning</a></li>
        <li style="padding-left: 32px"><a href="#62-abbey-finetuning-objectives">6.2 Abbey Fine‚ÄëTuning Objectives</a></li>
        <li style="padding-left: 32px"><a href="#63-aviva-finetuning-objectives">6.3 Aviva Fine‚ÄëTuning Objectives</a></li>
        <li style="padding-left: 32px"><a href="#64-abi-training-objectives">6.4 Abi Training Objectives</a></li>
        <li style="padding-left: 32px"><a href="#65-data-strategy">6.5 Data Strategy</a></li>
        <li style="padding-left: 32px"><a href="#66-feedback-and-continuous-learning">6.6 Feedback and Continuous Learning</a></li>
        <li style="padding-left: 16px"><a href="#7-evaluation">7. Evaluation</a></li>
        <li style="padding-left: 32px"><a href="#71-quality-metrics">7.1 Quality Metrics</a></li>
        <li style="padding-left: 32px"><a href="#72-persona-fidelity-metrics">7.2 Persona Fidelity Metrics</a></li>
        <li style="padding-left: 32px"><a href="#73-safety-and-policy-metrics">7.3 Safety and Policy Metrics</a></li>
        <li style="padding-left: 32px"><a href="#74-performance-metrics">7.4 Performance Metrics</a></li>
        <li style="padding-left: 32px"><a href="#75-suggested-benchmark-harness">7.5 Suggested Benchmark Harness</a></li>
        <li style="padding-left: 32px"><a href="#76-ablation-studies">7.6 Ablation Studies</a></li>
        <li style="padding-left: 16px"><a href="#8-security-privacy-and-compliance">8. Security, Privacy, and Compliance</a></li>
        <li style="padding-left: 32px"><a href="#81-data-minimization">8.1 Data Minimization</a></li>
        <li style="padding-left: 32px"><a href="#82-encryption-and-access-control">8.2 Encryption and Access Control</a></li>
        <li style="padding-left: 32px"><a href="#83-auditability">8.3 Auditability</a></li>
        <li style="padding-left: 32px"><a href="#84-user-control">8.4 User Control</a></li>
        <li style="padding-left: 32px"><a href="#85-compliance-posture">8.5 Compliance Posture</a></li>
        <li style="padding-left: 16px"><a href="#9-implementation-blueprint">9. Implementation Blueprint</a></li>
        <li style="padding-left: 32px"><a href="#91-services">9.1 Services</a></li>
        <li style="padding-left: 32px"><a href="#92-block-schema-illustrative">9.2 Block Schema (Illustrative)</a></li>
        <li style="padding-left: 32px"><a href="#93-operational-playbook">9.3 Operational Playbook</a></li>
        <li style="padding-left: 32px"><a href="#94-failure-modes-and-mitigations">9.4 Failure Modes and Mitigations</a></li>
        <li style="padding-left: 16px"><a href="#10-future-directions">10. Future Directions</a></li>
        <li style="padding-left: 16px"><a href="#conclusion">Conclusion</a></li>
        <li style="padding-left: 16px"><a href="#appendix-a-retrieval-scoring">Appendix A: Retrieval Scoring</a></li>
        <li style="padding-left: 16px"><a href="#appendix-b-recency-decay">Appendix B: Recency Decay</a></li>
        <li style="padding-left: 16px"><a href="#appendix-c-persona-preference-prior">Appendix C: Persona Preference Prior</a></li>
        <li style="padding-left: 16px"><a href="#appendix-d-simple-confidence-fusion">Appendix D: Simple Confidence Fusion</a></li>
      </ul></nav>
      <div class="doc-content"><h1 id="abbeyavivaabi-multipersona-ai-framework-with-wdbx-architecture">Abbey‚ÄìAviva‚ÄìAbi Multi‚ÄëPersona AI Framework with WDBX Architecture<a class="anchor" href="#abbeyavivaabi-multipersona-ai-framework-with-wdbx-architecture">#</a></h1>

<h2 id="abstract">Abstract<a class="anchor" href="#abstract">#</a></h2>

<p>Modern assistants are expected to be emotionally aware, technically correct, fast, and policy‚Äëaligned. Forcing these competing objectives through a single response style tends to produce inconsistent tone, excessive hedging, over‚Äërefusal, or brittle behavior when prompts shift. This whitepaper proposes a multi‚Äëpersona assistant architecture consisting of three specialized interaction models (Abbey, Aviva, Abi) routed through a transparent policy and blending layer, supported by a distributed neural database called WDBX (Wide Distributed Block Exchange).</p>

<p>WDBX is designed for high‚Äëdimensional embedding retrieval, multi‚Äëturn context continuity, and low‚Äëlatency, high‚Äëconcurrency operations under mixed read/write workloads. We describe the system design, routing logic, mathematical models for retrieval and persona selection, data management with MVCC and block chaining, evaluation methodology (including ablations), security and privacy controls, and a production implementation blueprint spanning storage, inference, observability, and governance.</p>

<h2 id="1-introduction">1. Introduction<a class="anchor" href="#1-introduction">#</a></h2>

<p>AI assistants are expected to behave like adaptable collaborators: empathetic when the user is frustrated, concise when the user is busy, rigorous when correctness matters, and compliant with safety constraints. Single‚Äëpersona systems must reconcile these demands simultaneously, leading to brittle tradeoffs: tone whiplash, refusal volatility, ‚Äúhelpful but vague‚Äù output, or policy behavior that feels unpredictable.</p>

<p>The Abbey‚ÄìAviva‚ÄìAbi framework decomposes assistant behavior into three roles:</p>

<li><strong>Abbey:</strong> the empathetic polymath for supportive, human‚Äëcentered communication while maintaining technical depth.</li>
<li><strong>Aviva:</strong> the unfiltered expert for direct, compressed, technically forceful output.</li>
<li><strong>Abi:</strong> the adaptive moderator and router that selects or blends personas, enforces constraints, and maintains intent alignment.</li>

<p>WDBX provides the memory substrate for long‚Äëcontext interaction, persona‚Äëaware retrieval, and traceable state transitions.</p>

<h3 id="11-problem-statement">1.1 Problem Statement<a class="anchor" href="#11-problem-statement">#</a></h3>

<p>The core engineering problem is not just ‚Äúgenerate text,‚Äù but control: control over style, correctness, safety posture, and continuity. Without modularity, a single model tends to blur objectives and amplify conflicts. A multi‚Äëpersona system creates an explicit place to resolve conflicts: routing, blending, and memory.</p>

<h3 id="12-contributions">1.2 Contributions<a class="anchor" href="#12-contributions">#</a></h3>

<p>This paper contributes:</p>

<p>1. A modular multi‚Äëpersona assistant architecture with explicit routing and blending.</p>
<p>2. WDBX, a distributed block‚Äëchained embedding store optimized for conversational continuity.</p>
<p>3. Formal models for retrieval scoring, persona selection, and latency.</p>
<p>4. An evaluation methodology with measurable metrics for quality, safety, persona fidelity, and performance.</p>
<p>5. A security and privacy model suitable for production deployments.</p>
<p>6. A deployment blueprint including sharding, replication, caching, observability, and failure handling.</p>

<h3 id="13-design-principles">1.3 Design Principles<a class="anchor" href="#13-design-principles">#</a></h3>

<li><strong>Separation of concerns:</strong> emotional calibration, direct technical output, and moderation are distinct objectives.</li>
<li><strong>Predictable control:</strong> the system can justify which persona acted and why, at an appropriate level.</li>
<li><strong>Continuity:</strong> long‚Äëcontext behavior is achieved through structured memory, not only context windows.</li>
<li><strong>Scalability:</strong> horizontal scaling for retrieval and inference with minimal coordination overhead.</li>
<li><strong>Safety by architecture:</strong> moderation is explicit and auditable, not implicit and inconsistent.</li>
<li><strong>Regression resistance:</strong> behavior changes must be measurable and testable (quality, safety, and latency).</li>

<h2 id="2-system-overview">2. System Overview<a class="anchor" href="#2-system-overview">#</a></h2>

<p>The system is organized into four planes:</p>

<p>1. <strong>Interaction Plane:</strong> user messages, attachments, tool calls, session metadata.</p>
<p>2. <strong>Persona Plane:</strong> Abbey, Aviva, Abi models (or persona‚Äëconditioned adapters on a shared base).</p>
<p>3. <strong>Routing Plane:</strong> intent detection, risk scoring, persona selection and blending, refusal logic.</p>
<p>4. <strong>Memory Plane:</strong> WDBX storage, indexing, retrieval, and trace emission.</p>

<h3 id="21-request-lifecycle">2.1 Request Lifecycle<a class="anchor" href="#21-request-lifecycle">#</a></h3>

<p>1. Receive user input, metadata, and tool context.</p>
<p>2. Compute intent embedding and safety/risk features.</p>
<p>3. Retrieve context candidates from WDBX (global + session chain).</p>
<p>4. Abi selects persona(s) and blending weights subject to constraints.</p>
<p>5. Generate response with persona tokens or adapters.</p>
<p>6. Store results, summaries, and trace artifacts back into WDBX.</p>

<h3 id="22-control-surfaces">2.2 Control Surfaces<a class="anchor" href="#22-control-surfaces">#</a></h3>

<p>Production systems benefit from explicit knobs:</p>

<li>persona preference (per user, per channel, per project)</li>
<li>aggressiveness of summarization and memory retention</li>
<li>risk thresholds for routing and refusal</li>
<li>retrieval depth (K) and rerank budget</li>
<li>latency budgets (p95/p99 targets) per tier</li>

<h3 id="23-data-flow-and-artifacts">2.3 Data Flow and Artifacts<a class="anchor" href="#23-data-flow-and-artifacts">#</a></h3>

<p>Each turn produces a compact set of stored artifacts:</p>

<li>query embedding</li>
<li>response embedding</li>
<li>optional summary embedding</li>
<li>routing decision and weights</li>
<li>policy/risk decision</li>
<li>retrieval ‚Äúevidence set‚Äù pointers</li>

<p>The objective is to store enough to reproduce decisions and maintain continuity without storing unnecessary private text.</p>

<h2 id="3-persona-design">3. Persona Design<a class="anchor" href="#3-persona-design">#</a></h2>

<h3 id="31-abbey-empathetic-polymath">3.1 Abbey: Empathetic Polymath<a class="anchor" href="#31-abbey-empathetic-polymath">#</a></h3>

<p>Abbey is optimized for:</p>

<li>emotional intelligence (tone matching, de‚Äëescalation)</li>
<li>deep technical assistance (systems, ML, code)</li>
<li>educational clarity and context‚Äëaware continuity</li>

<p>Typical use cases: mentoring, troubleshooting with frustration signals, high‚Äëstakes planning, collaborative writing.</p>

<p>Failure modes to test:</p>

<li>being overly gentle when the user needs strict technical correctness</li>
<li>adding unnecessary verbosity</li>
<li>premature reassurance without confirming constraints</li>

<h3 id="32-aviva-unfiltered-expert">3.2 Aviva: Unfiltered Expert<a class="anchor" href="#32-aviva-unfiltered-expert">#</a></h3>

<p>Aviva is optimized for:</p>

<li>directness and density</li>
<li>minimal hedging</li>
<li>strong technical prioritization and decisive recommendations</li>

<p>Typical use cases: debugging under time pressure, code review, architecture critiques, terse summaries.</p>

<p>Failure modes to test:</p>

<li>lack of empathy when the user is clearly stressed</li>
<li>overconfidence on uncertain facts</li>
<li>insufficient safety gating when risk is elevated</li>

<h3 id="33-abi-adaptive-moderator-and-router">3.3 Abi: Adaptive Moderator and Router<a class="anchor" href="#33-abi-adaptive-moderator-and-router">#</a></h3>

<p>Abi controls:</p>

<li>persona selection and blending</li>
<li>constraint enforcement (policy and safety)</li>
<li>refusal policy and redirection</li>
<li>traceability and audit logging</li>

<p>Abi does not need to be a large generative model; it can be a smaller policy model + rules + calibrated classifiers.</p>

<p>Key property: Abi should be stable under small prompt perturbations. If two prompts are semantically equivalent, routing decisions should not flip unpredictably.</p>

<h3 id="34-persona-contracts">3.4 Persona Contracts<a class="anchor" href="#34-persona-contracts">#</a></h3>

<p>A useful production pattern is to define ‚Äúcontracts‚Äù:</p>

<li>Abbey contract: clarity, supportive tone, helpfulness, correctness.</li>
<li>Aviva contract: brevity, decisiveness, technical sharpness, correctness.</li>
<li>Abi contract: alignment, stability, auditability, constraint enforcement.</li>

<p>Contracts become test targets: if you cannot measure them, you cannot keep them.</p>

<h2 id="4-wdbx-wide-distributed-block-exchange">4. WDBX: Wide Distributed Block Exchange<a class="anchor" href="#4-wdbx-wide-distributed-block-exchange">#</a></h2>

<p>WDBX is a distributed memory system for embedding storage and retrieval with a block‚Äëchaining model for semantic continuity.</p>

<h3 id="41-requirements">4.1 Requirements<a class="anchor" href="#41-requirements">#</a></h3>

<li>High‚Äëdimensional similarity search</li>
<li>Low latency at high QPS</li>
<li>Multi‚Äëturn session continuity</li>
<li>Concurrent writes (feedback, edits) without blocking reads</li>
<li>Traceable evolution of stored semantic state</li>
<li>Efficient retention and deletion policies</li>

<h3 id="42-data-model">4.2 Data Model<a class="anchor" href="#42-data-model">#</a></h3>

<p>Each stored unit is a Block.</p>

<p>Definition 1 (Block)</p>

<pre class="code-block"><code>B_t = {V_t, M_t, T_t, R_t, H_t}
</code></pre>

<li><strong>V_t:</strong> embedding vectors (query, response, summary, optional tool embeddings)</li>
<li><strong>M_t:</strong> metadata (persona tag, intent, risk score, content type, tenant)</li>
<li><strong>T_t:</strong> temporal markers (turn index, timestamps)</li>
<li><strong>R_t:</strong> references (parent pointer, skip pointers, shard pointers, evidence pointers)</li>
<li><strong>H_t:</strong> integrity fields (checksums, optional signatures)</li>

<p>A block is intentionally compact: the design prefers storing pointers and embeddings over raw conversation text unless explicitly required.</p>

<h3 id="43-block-chaining-for-continuity">4.3 Block Chaining for Continuity<a class="anchor" href="#43-block-chaining-for-continuity">#</a></h3>

<p>Conversation sessions form a chain:</p>

<pre class="code-block"><code>C = (B_1 \rightarrow B_2 \rightarrow \dots \rightarrow B_T)
</code></pre>

<p>To accelerate traversal, blocks may include skip pointers:</p>

<pre class="code-block"><code>R_t^{(\text{skip})}(k) = B_{t-2^k}
</code></pre>

<p>Skip pointers reduce the cost of retrieving far‚Äëback context in long sessions, and enable cheap ‚Äúwalk back‚Äù during summarization or dispute resolution.</p>

<h3 id="44-sharding-and-routing">4.4 Sharding and Routing<a class="anchor" href="#44-sharding-and-routing">#</a></h3>

<p>WDBX partitions data across nodes. A hybrid strategy is recommended:</p>

<li>shard by tenant/user</li>
<li>sub‚Äëshard by conversation/session</li>
<li>optionally cluster by semantic neighborhood</li>
<li>maintain a small routing index for shard pruning</li>

<p>Latency model (Eq. 1)</p>

<pre class="code-block"><code>L_{\text{shard}} = \alpha + \frac{\beta \cdot S}{n}
</code></pre>

<li><strong>\alpha:</strong> network overhead</li>
<li><strong>\beta:</strong> per‚Äëshard retrieval cost</li>
<li><strong>S:</strong> segment size referenced by query</li>
<li><strong>n:</strong> number of participating shards</li>

<p>A practical goal is to keep the expected shard fan‚Äëout bounded by a constant for most queries.</p>

<h3 id="45-mvcc-for-concurrent-readswrites">4.5 MVCC for Concurrent Reads/Writes<a class="anchor" href="#45-mvcc-for-concurrent-readswrites">#</a></h3>

<p>WDBX uses Multi‚ÄëVersion Concurrency Control so inference reads can remain consistent during updates.</p>

<p>Definition 2 (Visibility)</p>

<p>A transaction (x) sees version (v) iff:</p>

<pre class="code-block"><code>v.\text{commit_ts} \le x.\text{snapshot_ts} \wedge v.\text{end_ts} &gt; x.\text{snapshot_ts}
</code></pre>

<p>Implication: inference can operate on a stable snapshot while background processes write new versions (feedback corrections, embedding re‚Äëgeneration, updated summaries).</p>

<h3 id="46-retrieval-pipeline">4.6 Retrieval Pipeline<a class="anchor" href="#46-retrieval-pipeline">#</a></h3>

<p>A two‚Äëstage retrieval pipeline balances speed and recall:</p>

<p>1. Candidate generation: ANN index (IVF/HNSW), shard pruning, optional persona‚Äëlane filtering.</p>
<p>2. Reranking: exact distance + metadata filters + optional learned reranker.</p>

<p>End‚Äëto‚Äëend retrieval latency:</p>

<pre class="code-block"><code>L_{\text{retrieval}} = L_{\text{route}} + L_{\text{ANN}} + L_{\text{fetch}} + L_{\text{rerank}}
</code></pre>

<h3 id="47-compression-and-storage-efficiency">4.7 Compression and Storage Efficiency<a class="anchor" href="#47-compression-and-storage-efficiency">#</a></h3>

<p>To reduce memory and I/O, WDBX supports compressed representations:</p>

<li>product quantization (PQ) for vector compression</li>
<li>storing uncompressed vectors for refinement</li>
<li>tiered storage (hot RAM, warm SSD, cold object store)</li>

<p>A common pattern is ‚Äúcompressed for search, uncompressed for verify,‚Äù with refinement only on the top‚ÄëK candidates.</p>

<h3 id="48-replication-and-consistency">4.8 Replication and Consistency<a class="anchor" href="#48-replication-and-consistency">#</a></h3>

<p>WDBX replication is tuned for conversational systems:</p>

<li>asynchronous replication for low‚Äëlatency writes</li>
<li>quorum replication for high‚Äëintegrity deployments</li>
<li>session‚Äëcausal consistency to ensure a session reads its own writes in order</li>

<p>Definition 3 (Session Causality)</p>

<p>If B_i happens‚Äëbefore B_j within a session, reads should not observe B_j without B_i.</p>

<h3 id="49-summarization-blocks-and-memory-hygiene">4.9 Summarization Blocks and Memory Hygiene<a class="anchor" href="#49-summarization-blocks-and-memory-hygiene">#</a></h3>

<p>Long sessions require compaction:</p>

<li>periodic summary blocks that compress older turns</li>
<li>retention windows (time‚Äëbased, size‚Äëbased, sensitivity‚Äëbased)</li>
<li>deletion by user request with tombstones and GC</li>

<p>A simple compaction schedule can be ‚Äúsummarize every N turns,‚Äù with N adapted to latency budgets.</p>

<h3 id="410-integrity-and-audit-fields">4.10 Integrity and Audit Fields<a class="anchor" href="#410-integrity-and-audit-fields">#</a></h3>

<p>Integrity fields can support:</p>

<li>checksum verification</li>
<li>signed checkpoints for regulated environments</li>
<li>trace pointers for reproducibility</li>

<p>This is not ‚Äúblockchain for vibes.‚Äù It is a structured audit trail for decisions and continuity.</p>

<h2 id="5-persona-routing-and-blending">5. Persona Routing and Blending<a class="anchor" href="#5-persona-routing-and-blending">#</a></h2>

<h3 id="51-signals">5.1 Signals<a class="anchor" href="#51-signals">#</a></h3>

<p>Abi‚Äôs router uses features including:</p>

<li>intent classification (support, code, critique, planning)</li>
<li>user preference (explicit persona selection)</li>
<li>risk score (policy constraints)</li>
<li>frustration/urgency cues</li>
<li>task domain (security, finance, health)</li>
<li>uncertainty signals (low retrieval confidence, conflicting evidence)</li>

<h3 id="52-persona-selection-model">5.2 Persona Selection Model<a class="anchor" href="#52-persona-selection-model">#</a></h3>

<p>Let x be a request representation. Abi computes persona logits:</p>

<pre class="code-block"><code>\ell = f(x) \in \mathbb{R}^3
</code></pre>

<p>Converted to weights via softmax:</p>

<pre class="code-block"><code>w_i = \frac{e^{\ell_i}}{\sum_j e^{\ell_j}}
</code></pre>

<p>Then either:</p>

<li>select \arg\max_i w_i (hard routing), or</li>
<li>mix outputs using w (soft blending) with constraints.</li>

<h3 id="53-blending-constraints">5.3 Blending Constraints<a class="anchor" href="#53-blending-constraints">#</a></h3>

<p>To prevent incoherent responses, blending is constrained:</p>

<li>restrict to at most two personas per turn</li>
<li>enforce a minimum dominance threshold (e.g., max weight &gt; 0.7)</li>
<li>forbid Aviva dominance when policy risk exceeds threshold</li>
<li>avoid ‚Äútone oscillation‚Äù by adding a hysteresis term</li>

<p>Hysteresis sketch (Eq. 2)</p>

<pre class="code-block"><code>\ell' = \ell + \tau \cdot \ell_{\text{prev}}
</code></pre>

<p>Where \tau controls how strongly the previous routing influences the current decision.</p>

<h3 id="54-user-override">5.4 User Override<a class="anchor" href="#54-user-override">#</a></h3>

<p>If the user explicitly requests Aviva or Abbey, override routing unless safety constraints require moderation.</p>

<h3 id="55-explainable-routing">5.5 Explainable Routing<a class="anchor" href="#55-explainable-routing">#</a></h3>

<p>Abi should be able to produce a short, non‚Äësensitive explanation of its choice, especially in enterprise contexts. Examples of explainable features:</p>

<li>user preference signal present</li>
<li>urgency detected</li>
<li>elevated risk threshold triggered</li>
<li>retrieval confidence low, requiring careful tone</li>

<p>Explainability is not for philosophical comfort; it reduces debugging time and increases trust.</p>

<h2 id="6-training-methodology">6. Training Methodology<a class="anchor" href="#6-training-methodology">#</a></h2>

<h3 id="61-base-model-and-persona-conditioning">6.1 Base Model and Persona Conditioning<a class="anchor" href="#61-base-model-and-persona-conditioning">#</a></h3>

<p>Two viable approaches:</p>

<p>1. Persona tokens injected into the prompt.</p>
<p>2. Adapters/LoRA per persona with shared base weights.</p>

<p>A hybrid strategy is common: persona tokens for quick switching plus adapters for strong separation.</p>

<h3 id="62-abbey-finetuning-objectives">6.2 Abbey Fine‚ÄëTuning Objectives<a class="anchor" href="#62-abbey-finetuning-objectives">#</a></h3>

<pre class="code-block"><code>\mathcal{L}_{\text{Abbey}} = \mathcal{L}_{\text{task}} + \gamma \mathcal{L}_{\text{tone}} + \delta \mathcal{L}_{\text{coherence}}
</code></pre>

<li><strong>\mathcal{L}_{\text{tone}}:</strong> penalize mismatch with target empathy/clarity</li>
<li><strong>\mathcal{L}_{\text{coherence}}:</strong> long‚Äëcontext consistency</li>

<h3 id="63-aviva-finetuning-objectives">6.3 Aviva Fine‚ÄëTuning Objectives<a class="anchor" href="#63-aviva-finetuning-objectives">#</a></h3>

<pre class="code-block"><code>\mathcal{L}_{\text{Aviva}} = \mathcal{L}_{\text{task}} + \eta \mathcal{L}_{\text{brevity}} - \kappa \mathcal{L}_{\text{hedge}}
</code></pre>

<li>brevity encourages density while preserving correctness</li>
<li>hedge penalty reduces unnecessary apologetics and hedging</li>

<h3 id="64-abi-training-objectives">6.4 Abi Training Objectives<a class="anchor" href="#64-abi-training-objectives">#</a></h3>

<p>Abi is trained for calibrated decisions:</p>

<pre class="code-block"><code>\mathcal{L}_{\text{Abi}} = \mathcal{L}_{\text{route}} + \lambda \mathcal{L}_{\text{policy}} + \mu \mathcal{L}_{\text{stability}}
</code></pre>

<li>routing accuracy</li>
<li>policy compliance</li>
<li>stability across prompt perturbations</li>

<h3 id="65-data-strategy">6.5 Data Strategy<a class="anchor" href="#65-data-strategy">#</a></h3>

<p>A robust dataset mix includes:</p>

<li>task corpora for code, systems, and planning</li>
<li>dialog corpora with labeled empathy and tone targets</li>
<li>safety policy examples with fine‚Äëgrained labels</li>
<li>retrieval‚Äëgrounded examples (answer must cite retrieved facts)</li>

<h3 id="66-feedback-and-continuous-learning">6.6 Feedback and Continuous Learning<a class="anchor" href="#66-feedback-and-continuous-learning">#</a></h3>

<li>preference tuning (pairwise rankings)</li>
<li>regression tests for safety and style</li>
<li>drift detection on user satisfaction and refusal rates</li>
<li>‚Äúcanary prompts‚Äù to detect sudden persona regressions</li>

<p>A practical governance rule: never ship a persona update without running a fixed suite of routing and safety tests.</p>

<h2 id="7-evaluation">7. Evaluation<a class="anchor" href="#7-evaluation">#</a></h2>

<h3 id="71-quality-metrics">7.1 Quality Metrics<a class="anchor" href="#71-quality-metrics">#</a></h3>

<li>task success rate</li>
<li>factuality checks (self‚Äëconsistency + retrieval grounding)</li>
<li>code correctness (unit tests, compilation)</li>
<li>coherence across turns</li>
<li>tool‚Äëuse correctness (if tools are integrated)</li>

<h3 id="72-persona-fidelity-metrics">7.2 Persona Fidelity Metrics<a class="anchor" href="#72-persona-fidelity-metrics">#</a></h3>

<li>tone consistency score (classifier)</li>
<li>verbosity compression ratio</li>
<li>hedging frequency</li>
<li>‚ÄúAbbey warmth‚Äù vs ‚ÄúAviva sharpness‚Äù separation score</li>

<h3 id="73-safety-and-policy-metrics">7.3 Safety and Policy Metrics<a class="anchor" href="#73-safety-and-policy-metrics">#</a></h3>

<li>refusal correctness</li>
<li>harmful content leakage rate</li>
<li>false refusal rate</li>
<li>policy‚Äërouting stability under paraphrase</li>

<h3 id="74-performance-metrics">7.4 Performance Metrics<a class="anchor" href="#74-performance-metrics">#</a></h3>

<li>p50/p95/p99 retrieval latency</li>
<li>throughput (QPS) under concurrency</li>
<li>write amplification and storage cost</li>
<li>cache hit rates (hot shards, embeddings, rerank)</li>

<h3 id="75-suggested-benchmark-harness">7.5 Suggested Benchmark Harness<a class="anchor" href="#75-suggested-benchmark-harness">#</a></h3>

<p>A reproducible harness should include:</p>

<li>fixed datasets (embeddings + metadata)</li>
<li>workload generator (read/write mix)</li>
<li>measured latencies per pipeline stage</li>
<li>persona routing stress tests</li>
<li>failure injection (node loss, shard lag, stale replicas)</li>

<h3 id="76-ablation-studies">7.6 Ablation Studies<a class="anchor" href="#76-ablation-studies">#</a></h3>

<p>Recommended ablations:</p>

<li>single persona vs multi‚Äëpersona (quality and safety)</li>
<li>hard routing vs blended routing</li>
<li>WDBX chain retrieval vs flat vector retrieval</li>
<li>MVCC vs locking (latency under concurrent writes)</li>

<p>Ablations turn architecture claims into measurable engineering facts.</p>

<h2 id="8-security-privacy-and-compliance">8. Security, Privacy, and Compliance<a class="anchor" href="#8-security-privacy-and-compliance">#</a></h2>

<h3 id="81-data-minimization">8.1 Data Minimization<a class="anchor" href="#81-data-minimization">#</a></h3>

<li>store only needed artifacts</li>
<li>redact sensitive user data where possible</li>
<li>separate identifying data from embeddings</li>
<li>minimize raw text retention unless explicitly required</li>

<h3 id="82-encryption-and-access-control">8.2 Encryption and Access Control<a class="anchor" href="#82-encryption-and-access-control">#</a></h3>

<li>AES‚Äë256 at rest</li>
<li>TLS in transit</li>
<li>role‚Äëbased access control</li>
<li>per‚Äëtenant keying where applicable</li>
<li>audit logs for access and deletion</li>

<h3 id="83-auditability">8.3 Auditability<a class="anchor" href="#83-auditability">#</a></h3>

<li>block chaining provides traceable state</li>
<li>logs for persona selection decisions</li>
<li>signed checkpoints for sensitive deployments</li>
<li>reproducible ‚Äúwhy this answer‚Äù trace pointers</li>

<h3 id="84-user-control">8.4 User Control<a class="anchor" href="#84-user-control">#</a></h3>

<li>memory export and deletion</li>
<li>persona preference controls</li>
<li>opt‚Äëout of training data usage</li>
<li>configurable retention policies</li>

<h3 id="85-compliance-posture">8.5 Compliance Posture<a class="anchor" href="#85-compliance-posture">#</a></h3>

<p>WDBX and routing traces enable:</p>

<li>incident investigation without storing unnecessary personal text</li>
<li>retention enforcement</li>
<li>demonstrable policy behavior over time</li>

<p>Compliance is a product feature when it prevents expensive surprises.</p>

<h2 id="9-implementation-blueprint">9. Implementation Blueprint<a class="anchor" href="#9-implementation-blueprint">#</a></h2>

<h3 id="91-services">9.1 Services<a class="anchor" href="#91-services">#</a></h3>

<li>Gateway: auth, rate limiting, request normalization</li>
<li>Router (Abi): intent + risk + persona weights + explainability</li>
<li>Retriever (WDBX): candidate + rerank + evidence pointers</li>
<li>Generator: persona‚Äëconditioned inference</li>
<li>Writer: block creation, MVCC versioning, compaction jobs</li>
<li>Telemetry: metrics, traces, audit logs</li>

<h3 id="92-block-schema-illustrative">9.2 Block Schema (Illustrative)<a class="anchor" href="#92-block-schema-illustrative">#</a></h3>

<li>block_id</li>
<li>tenant_id</li>
<li>session_id</li>
<li>turn_index</li>
<li>created_at</li>
<li>persona_tag</li>
<li>intent_tag</li>
<li>risk_score</li>
<li>embedding_query</li>
<li>embedding_response</li>
<li>summary_embedding</li>
<li>evidence_block_ids</li>
<li>parent_block_id</li>
<li>skip_pointers</li>
<li>checksums</li>
<li>version fields (commit_ts, end_ts)</li>

<h3 id="93-operational-playbook">9.3 Operational Playbook<a class="anchor" href="#93-operational-playbook">#</a></h3>

<li>blue/green deploys for router changes</li>
<li>canary prompts and regression suites</li>
<li>snapshot backups for WDBX metadata and routing logs</li>
<li>rolling compaction windows to avoid latency spikes</li>

<h3 id="94-failure-modes-and-mitigations">9.4 Failure Modes and Mitigations<a class="anchor" href="#94-failure-modes-and-mitigations">#</a></h3>

<li>Context drift: periodic summarization blocks + recency weighting.</li>
<li>Shard hotspots: adaptive sharding and workload‚Äëaware routing.</li>
<li>Incoherent persona blending: constrained blending and dominance thresholds.</li>
<li>Over‚Äërefusal: calibrated risk models and regression tests.</li>
<li>Stale replicas: session‚Äëcausal reads, replica health scoring.</li>

<h2 id="10-future-directions">10. Future Directions<a class="anchor" href="#10-future-directions">#</a></h2>

<li>multimodal memory blocks (image/audio embeddings)</li>
<li>hierarchical memory (episodic vs semantic)</li>
<li>tighter integration with long‚Äëcontext attention mechanisms</li>
<li>differential privacy options for enterprise deployments</li>
<li>hardware‚Äëaccelerated vector search (SIMD/GPU)</li>
<li>persona‚Äëspecific ‚Äústyle embeddings‚Äù for stronger separation</li>

<h2 id="conclusion">Conclusion<a class="anchor" href="#conclusion">#</a></h2>

<p>The Abbey‚ÄìAviva‚ÄìAbi framework reframes assistant behavior as a controllable, modular system rather than a single blended personality. WDBX provides a scalable memory substrate with semantic continuity via block chaining, high concurrency via MVCC, and low latency via shard‚Äëaware indexing and reranking. Together, these components enable assistants to remain emotionally calibrated, technically effective, and policy aligned while retaining long‚Äëterm conversational coherence.</p>

<h2 id="appendix-a-retrieval-scoring">Appendix A: Retrieval Scoring<a class="anchor" href="#appendix-a-retrieval-scoring">#</a></h2>

<p>A hybrid score combines similarity and metadata relevance:</p>

<pre class="code-block"><code>\text{score}(B_i, q) = \lambda \cdot \cos(V_i, q) + (1-\lambda)\cdot g(M_i, T_i)
</code></pre>

<p>Where g may incorporate recency decay, persona matching, and evidence confidence.</p>

<h2 id="appendix-b-recency-decay">Appendix B: Recency Decay<a class="anchor" href="#appendix-b-recency-decay">#</a></h2>

<p>Example exponential decay:</p>

<pre class="code-block"><code>\text{recency}(\Delta t) = e^{-\rho \Delta t}
</code></pre>

<p>A practical enhancement is to cap decay to preserve a minimum influence for key ‚Äúidentity‚Äù blocks.</p>

<h2 id="appendix-c-persona-preference-prior">Appendix C: Persona Preference Prior<a class="anchor" href="#appendix-c-persona-preference-prior">#</a></h2>

<p>User preference prior (p) can be fused with router weights (w):</p>

<pre class="code-block"><code>\tilde{w} = \text{normalize}(w \odot p)
</code></pre>

<h2 id="appendix-d-simple-confidence-fusion">Appendix D: Simple Confidence Fusion<a class="anchor" href="#appendix-d-simple-confidence-fusion">#</a></h2>

<p>If retrieval confidence (c \in [0, 1]) is available, routing can be made more conservative when c is low:</p>

<pre class="code-block"><code>\ell_{\text{safe}} = \ell - \upsilon (1-c)
</code></pre>

<p>Where \upsilon increases cautious routing under low confidence.</p>
<p></p>
</div>
    </article>
  </main>
</div>
<footer class="footer" style="margin-left: 0;">
  <div class="footer-content">
    <div class="footer-section">
      <h4>ABI Framework</h4>
      <p>Modern Zig framework for AI services and high-performance systems.</p>
    </div>
  </div>
  <div class="footer-bottom"><p>&copy; 2026 ABI Framework. Built with Zig.</p></div>
</footer>
<script src="/abi/assets/js/main.js"></script>
</body>
</html>
