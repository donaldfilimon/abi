#!/usr/bin/env bash
#
# ABI Framework - Pre-commit Hook
#
# Checks:
#   1. zig fmt --check on staged .zig files
#   2. Warns if mod.zig is staged without its corresponding stub.zig
#   3. Blocks commits containing credential/secret files
#
# Install: git config core.hooksPath .githooks

set -euo pipefail

# Colors (disabled if not a terminal or on dumb terminals)
if [ -t 1 ] && [ "${TERM:-dumb}" != "dumb" ]; then
    RED='\033[0;31m'
    YELLOW='\033[0;33m'
    GREEN='\033[0;32m'
    BOLD='\033[1m'
    RESET='\033[0m'
else
    RED=''
    YELLOW=''
    GREEN=''
    BOLD=''
    RESET=''
fi

ERRORS=0
WARNINGS=0

echo -e "${BOLD}ABI pre-commit checks${RESET}"
echo "─────────────────────"

# ─────────────────────────────────────────────
# 1. Block credential and secret files
# ─────────────────────────────────────────────
BLOCKED_PATTERNS='\.env$|\.env\.|\.pem$|\.key$|\.p12$|\.pfx$|\.jks$|credentials\.json$|secret|\.secret'

BLOCKED_FILES=$(git diff --cached --name-only --diff-filter=ACR | grep -iE "$BLOCKED_PATTERNS" || true)

if [ -n "$BLOCKED_FILES" ]; then
    echo ""
    echo -e "${RED}${BOLD}BLOCKED: Credential/secret files detected in staging area:${RESET}"
    echo "$BLOCKED_FILES" | while IFS= read -r file; do
        echo -e "  ${RED}  $file${RESET}"
    done
    echo ""
    echo -e "${YELLOW}If this is intentional, commit with --no-verify${RESET}"
    ERRORS=1
fi

# ─────────────────────────────────────────────
# 2. Zig formatting check (staged .zig files only)
# ─────────────────────────────────────────────
STAGED_ZIG=$(git diff --cached --name-only --diff-filter=ACMR | grep '\.zig$' || true)

if [ -n "$STAGED_ZIG" ]; then
    echo -e "\n${BOLD}Checking zig fmt...${RESET}"

    # Check if zig is available
    if ! command -v zig &>/dev/null; then
        echo -e "${YELLOW}WARNING: zig not found in PATH, skipping format check${RESET}"
    else
        # Run zig fmt --check on the whole project (fast, checks all .zig files)
        FMT_OUTPUT=$(zig fmt --check . 2>&1) || FMT_EXIT=$?
        FMT_EXIT=${FMT_EXIT:-0}

        if [ "$FMT_EXIT" -ne 0 ]; then
            echo -e "${RED}${BOLD}FAILED: Zig formatting issues found${RESET}"
            echo ""
            # Show only files that are also staged
            while IFS= read -r staged_file; do
                if echo "$FMT_OUTPUT" | grep -q "$staged_file"; then
                    echo -e "  ${RED}  $staged_file${RESET}"
                fi
            done <<< "$STAGED_ZIG"
            echo ""
            echo -e "${YELLOW}Run 'zig fmt .' to fix formatting, then re-stage your changes.${RESET}"
            ERRORS=1
        else
            echo -e "  ${GREEN}All staged .zig files are formatted correctly${RESET}"
        fi
    fi
else
    echo -e "\n  No .zig files staged, skipping format check"
fi

# ─────────────────────────────────────────────
# 3. Stub/mod parity warning
# ─────────────────────────────────────────────
STAGED_MODS=$(git diff --cached --name-only --diff-filter=ACMR | grep 'mod\.zig$' || true)

if [ -n "$STAGED_MODS" ]; then
    echo -e "\n${BOLD}Checking mod.zig / stub.zig parity...${RESET}"

    while IFS= read -r mod_file; do
        MOD_DIR=$(dirname "$mod_file")
        STUB_FILE="$MOD_DIR/stub.zig"

        # Check if a stub.zig exists in the same directory
        if [ -f "$STUB_FILE" ]; then
            # Check if stub.zig is also staged
            if ! git diff --cached --name-only | grep -q "^${STUB_FILE}$"; then
                echo -e "  ${YELLOW}WARNING: $mod_file is staged but $STUB_FILE is not${RESET}"
                echo -e "  ${YELLOW}         Feature stubs must stay in sync with their mod.zig${RESET}"
                WARNINGS=$((WARNINGS + 1))
            else
                echo -e "  ${GREEN}  $mod_file  <->  $STUB_FILE${RESET}"
            fi
        fi
    done <<< "$STAGED_MODS"
fi

# ─────────────────────────────────────────────
# Summary
# ─────────────────────────────────────────────
echo ""
if [ "$ERRORS" -ne 0 ]; then
    echo -e "${RED}${BOLD}Pre-commit checks FAILED${RESET}"
    echo -e "${YELLOW}Fix the issues above or use 'git commit --no-verify' to bypass.${RESET}"
    exit 1
fi

if [ "$WARNINGS" -ne 0 ]; then
    echo -e "${YELLOW}${BOLD}Pre-commit passed with $WARNINGS warning(s)${RESET}"
else
    echo -e "${GREEN}${BOLD}Pre-commit checks passed${RESET}"
fi

exit 0
