//! Auth module standalone tests.
//! Separated from mod.zig to avoid pulling in security sub-modules that have
//! pre-existing Zig 0.16 compile issues (rbac, secrets, session, validation).

const std = @import("std");
const auth = @import("mod.zig");

test "auth context init and deinit" {
    const allocator = std.testing.allocator;
    const ctx = try auth.Context.init(allocator, auth.AuthConfig.defaults());
    defer ctx.deinit();
    try std.testing.expect(@intFromPtr(ctx) != 0);
}

test "auth module enabled and initialized" {
    try std.testing.expect(auth.isEnabled());
    try std.testing.expect(auth.isInitialized());
}

test "auth token creation delegates to jwt module" {
    const allocator = std.testing.allocator;
    const token = try auth.createToken(allocator, "user123");
    defer allocator.free(token.raw);
    // Token is now a real JWT (3 dot-separated base64url parts)
    try std.testing.expect(token.raw.len > 0);
    var parts = std.mem.splitScalar(u8, token.raw, '.');
    _ = parts.next(); // header
    _ = parts.next(); // payload
    _ = parts.next(); // signature
    try std.testing.expect(parts.next() == null); // no extra parts
    try std.testing.expectEqualStrings("user123", token.claims.sub);
}

test "auth token verify round-trip" {
    const allocator = std.testing.allocator;
    // Create a token, then verify it — full round-trip.
    const created = try auth.createToken(allocator, "roundtrip_user");
    defer allocator.free(created.raw);

    const verified = try auth.verifyToken(created.raw);
    // sub is heap-allocated by verifyToken via page_allocator; free it.
    defer if (verified.claims.sub.len > 0) std.heap.page_allocator.free(verified.claims.sub);
    try std.testing.expectEqualStrings("roundtrip_user", verified.claims.sub);
    try std.testing.expect(verified.claims.exp > 0);
}

test "auth permission check delegates to rbac" {
    // Without role assignments the ephemeral RbacManager returns false.
    const result = try auth.checkPermission("user123", .read);
    try std.testing.expect(!result);
}

test "auth session creation delegates to session module" {
    const allocator = std.testing.allocator;
    const session_inst = try auth.createSession(allocator, "user456");
    defer allocator.free(session_inst.id);
    defer if (session_inst.user_id.len > 0) allocator.free(session_inst.user_id);
    // Session now has a real ID generated by SessionManager
    try std.testing.expect(session_inst.id.len > 0);
    try std.testing.expectEqualStrings("user456", session_inst.user_id);
    // Note: time.unixSeconds() returns monotonic seconds since app start (not
    // Unix epoch), so created_at may be 0 if the test runs within the first
    // second. We verify expires_at > created_at (lifetime is added).
    try std.testing.expect(session_inst.expires_at >= session_inst.created_at);
    try std.testing.expect(session_inst.expires_at > 0);
}

test "auth error type variants" {
    const err: auth.AuthError = error.InvalidCredentials;
    try std.testing.expect(err == error.InvalidCredentials);
    const err2: auth.AuthError = error.TokenExpired;
    try std.testing.expect(err2 == error.TokenExpired);
}

test "auth type definitions" {
    const token = auth.Token{};
    try std.testing.expectEqualStrings("", token.raw);
    try std.testing.expectEqual(@as(u64, 0), token.claims.exp);

    const sess = auth.Session{};
    try std.testing.expectEqualStrings("", sess.id);
    try std.testing.expectEqual(@as(u64, 0), sess.expires_at);
}

test "auth permission enum" {
    const perm: auth.Permission = .read;
    try std.testing.expect(perm == .read);
    const perm2: auth.Permission = .write;
    try std.testing.expect(perm2 != .admin);
}

// ── Additional inline tests ───────────────────────────────────────────

test "auth JWT has three base64url parts" {
    const allocator = std.testing.allocator;
    const token = try auth.createToken(allocator, "jwt_struct_user");
    defer allocator.free(token.raw);

    // A valid JWT always has exactly 3 dot-separated segments
    var count: u32 = 0;
    var it = std.mem.splitScalar(u8, token.raw, '.');
    while (it.next()) |_| count += 1;
    try std.testing.expectEqual(@as(u32, 3), count);

    // Each segment must be non-empty
    var it2 = std.mem.splitScalar(u8, token.raw, '.');
    while (it2.next()) |seg| {
        try std.testing.expect(seg.len > 0);
    }
}

test "auth verifyToken rejects tampered payload" {
    const allocator = std.testing.allocator;
    const token = try auth.createToken(allocator, "tamper_user");
    defer allocator.free(token.raw);

    // Tamper with the payload (second segment): flip a character
    var tampered = try allocator.dupe(u8, token.raw);
    defer allocator.free(tampered);

    // Find second dot-separated segment and flip a byte in it
    if (std.mem.indexOfScalar(u8, tampered, '.')) |first_dot| {
        if (std.mem.indexOfScalarPos(u8, tampered, first_dot + 1, '.')) |second_dot| {
            const mid = first_dot + 1 + (second_dot - first_dot - 1) / 2;
            tampered[mid] ^= 0x01;
        }
    }

    const result = auth.verifyToken(tampered);
    try std.testing.expectError(error.InvalidCredentials, result);
}

test "auth verifyToken rejects empty string" {
    const result = auth.verifyToken("");
    try std.testing.expectError(error.InvalidCredentials, result);
}

test "auth verifyToken rejects malformed token" {
    const result = auth.verifyToken("not-a-jwt-token");
    try std.testing.expectError(error.InvalidCredentials, result);
}

test "auth checkPermission admin returns false without role assignment" {
    // An ephemeral RbacManager with no role assignments always returns false
    const result = try auth.checkPermission("admin_user", .admin);
    try std.testing.expect(!result);
}

test "auth checkPermission write returns false without role assignment" {
    const result = try auth.checkPermission("some_user", .write);
    try std.testing.expect(!result);
}

test "auth session IDs are unique across users" {
    const allocator = std.testing.allocator;

    const s1 = try auth.createSession(allocator, "user_aaa");
    defer allocator.free(s1.id);
    defer if (s1.user_id.len > 0) allocator.free(s1.user_id);

    const s2 = try auth.createSession(allocator, "user_bbb");
    defer allocator.free(s2.id);
    defer if (s2.user_id.len > 0) allocator.free(s2.user_id);

    // Session IDs must differ
    try std.testing.expect(!std.mem.eql(u8, s1.id, s2.id));
}

test "auth session timestamps are valid" {
    const allocator = std.testing.allocator;
    const sess = try auth.createSession(allocator, "ts_user");
    defer allocator.free(sess.id);
    defer if (sess.user_id.len > 0) allocator.free(sess.user_id);

    // expires_at must be >= created_at (lifetime is added)
    try std.testing.expect(sess.expires_at >= sess.created_at);
    // expires_at should be strictly positive (session has a real lifetime)
    try std.testing.expect(sess.expires_at > 0);
}

test "auth createToken verifyToken round-trip preserves user_id" {
    const allocator = std.testing.allocator;
    const user_ids = [_][]const u8{ "alice", "bob", "charlie" };

    for (user_ids) |uid| {
        const token = try auth.createToken(allocator, uid);
        defer allocator.free(token.raw);

        const verified = try auth.verifyToken(token.raw);
        defer if (verified.claims.sub.len > 0)
            std.heap.page_allocator.free(verified.claims.sub);

        try std.testing.expectEqualStrings(uid, verified.claims.sub);
    }
}

test "auth token claims sub matches input" {
    const allocator = std.testing.allocator;
    const token = try auth.createToken(allocator, "claims_check");
    defer allocator.free(token.raw);
    try std.testing.expectEqualStrings("claims_check", token.claims.sub);
}
