//! Auth module standalone tests.
//! Separated from mod.zig to avoid pulling in security sub-modules that have
//! pre-existing Zig 0.16 compile issues (rbac, secrets, session, validation).

const std = @import("std");
const auth = @import("mod.zig");

test "auth context init and deinit" {
    const allocator = std.testing.allocator;
    const ctx = try auth.Context.init(allocator, auth.AuthConfig.defaults());
    defer ctx.deinit();
    try std.testing.expect(@intFromPtr(ctx) != 0);
}

test "auth module enabled and initialized" {
    try std.testing.expect(auth.isEnabled());
    try std.testing.expect(auth.isInitialized());
}

test "auth token creation delegates to jwt module" {
    const allocator = std.testing.allocator;
    const token = try auth.createToken(allocator, "user123");
    defer allocator.free(token.raw);
    // Token is now a real JWT (3 dot-separated base64url parts)
    try std.testing.expect(token.raw.len > 0);
    var parts = std.mem.splitScalar(u8, token.raw, '.');
    _ = parts.next(); // header
    _ = parts.next(); // payload
    _ = parts.next(); // signature
    try std.testing.expect(parts.next() == null); // no extra parts
    try std.testing.expectEqualStrings("user123", token.claims.sub);
}

test "auth token verify round-trip" {
    const allocator = std.testing.allocator;
    // Create a token, then verify it â€” full round-trip.
    const created = try auth.createToken(allocator, "roundtrip_user");
    defer allocator.free(created.raw);

    const verified = try auth.verifyToken(created.raw);
    // sub is heap-allocated by verifyToken via page_allocator; free it.
    defer if (verified.claims.sub.len > 0) std.heap.page_allocator.free(verified.claims.sub);
    try std.testing.expectEqualStrings("roundtrip_user", verified.claims.sub);
    try std.testing.expect(verified.claims.exp > 0);
}

test "auth permission check delegates to rbac" {
    // Without role assignments the ephemeral RbacManager returns false.
    const result = try auth.checkPermission("user123", .read);
    try std.testing.expect(!result);
}

test "auth session creation delegates to session module" {
    const allocator = std.testing.allocator;
    const session_inst = try auth.createSession(allocator, "user456");
    defer allocator.free(session_inst.id);
    defer if (session_inst.user_id.len > 0) allocator.free(session_inst.user_id);
    // Session now has a real ID generated by SessionManager
    try std.testing.expect(session_inst.id.len > 0);
    try std.testing.expectEqualStrings("user456", session_inst.user_id);
    // Note: time.unixSeconds() returns monotonic seconds since app start (not
    // Unix epoch), so created_at may be 0 if the test runs within the first
    // second. We verify expires_at > created_at (lifetime is added).
    try std.testing.expect(session_inst.expires_at >= session_inst.created_at);
    try std.testing.expect(session_inst.expires_at > 0);
}

test "auth error type variants" {
    const err: auth.AuthError = error.InvalidCredentials;
    try std.testing.expect(err == error.InvalidCredentials);
    const err2: auth.AuthError = error.TokenExpired;
    try std.testing.expect(err2 == error.TokenExpired);
}

test "auth type definitions" {
    const token = auth.Token{};
    try std.testing.expectEqualStrings("", token.raw);
    try std.testing.expectEqual(@as(u64, 0), token.claims.exp);

    const sess = auth.Session{};
    try std.testing.expectEqualStrings("", sess.id);
    try std.testing.expectEqual(@as(u64, 0), sess.expires_at);
}

test "auth permission enum" {
    const perm: auth.Permission = .read;
    try std.testing.expect(perm == .read);
    const perm2: auth.Permission = .write;
    try std.testing.expect(perm2 != .admin);
}
